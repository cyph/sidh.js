{"version":3,"file":"dist/sidh.debug.js","sources":["libsodium/src/libsodium/sodium/utils.c","libsodium/src/libsodium/randombytes/randombytes.c","SIDH_v1.0/SIDH_setup.c","SIDH_v1.0/ec_isogeny.c","SIDH_v1.0/fpx.c","SIDH_v1.0/SIDH_internal.h","SIDH_v1.0/generic/fp_generic.c","SIDH_v1.0/generic/../SIDH_internal.h","SIDH_v1.0/kex.c","SIDH_v1.0/validate.c","sidh.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyJA;AADA;AAGA;AADA;AAGA;AACA;AAMA;AAAA;;AACA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;ACrGA;AAAA;;;;;AAeA;AA4BA;;;;;;;;;;AAsCA;AAAA;AAGA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAIA;;;;;;;;;;;;;;;;;;;ACxIA;AAAA;;AACA;AA8BA;AAAA;;AA3BA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;;;;;;;;;;;AAkEA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAIA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;AAHA;AAAA;AAGA;AAAA;AAAA;;;;;;;;;;;AAnEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AACA;AAGA;AAAA;;AADA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;AAqFA;AACA;AAAA;AAEA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AACA;AACA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;;;AAIA;AAAA;AAAA;AACA;AAAA;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;;;AAPA;AAmBA;AAAA;;;AAfA;AAAA;AAeA;AAAA;;;AAVA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAGA;AAAA;AACA;AAAA;;;;AAzCA;AAyCA;AAAA;;;;;;;;;;AAkDA;AAAA;AAEA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;;;;;;;;;;;;;ACtPA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;AAUA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;AA+BA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;AAOA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;;;;;;;;;;;;;;AASA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AASA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AC3hBA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;;;;;;;AAOA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAEA;;;;;;;;;;AAQA;AAAA;AAAA;AACA;;;;;;;;;;;;;AA0HA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;AAxHA;AAEA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;AA2CA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;;;;;;;;;;;;;;;AAKA;AAEA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAIA;AAAA;;;;;;;;;;ACpCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AALA;AAAA;AAAA;AAAA;;;;;;;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;ADoDA;AAEA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAIA;AAAA;;;;;;;;;;;AAQA;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;AAOA;AAAA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;AA6BA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AASA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AACA;;AAAA;AAAA;;;;AACA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AAFA;AAAA;AAAA;;AAIA;AAAA;AAAA;AACA;;;;;;;;;;AAQA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAYA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;AAUA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;;;;;;;;;;AAOA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAOA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AAOA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;AASA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AANA;AAAA;AAAA;;AAQA;;;;;;;;;;;;;;;;;;;AASA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAZA;AAAA;AAAA;;AAcA;;;;;;;;;;;;;;;;AAQA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;;AAIA;;;;;;;;;;;;;;;;;AEldA;AAGA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAIA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAEA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;;;;;;;;;ACyCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AALA;AAAA;AAAA;AAAA;;;;;;;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;ADxBA;AAGA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAEA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;;;;;;;;AAMA;AAEA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;;;;;;;;;;;AAOA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAIA;AAAA;AACA;;;;;;;;;;;;;;;;AAOA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;AAOA;AAEA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AAAA;;;;AACA;AACA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;;;;;;;;;;;;;;;;AAtWA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;AA/JA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;AAvHA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;AAsDA;AAAA;AAIA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AACA;AAAA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;;;AAAA;;AAAA;;AAAA;;;;;;;;;;;;AAnGA;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AADA;AAAA;AAAA;;;AAEA;AAAA;AAKA;AAAA;AAAA;;;AADA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAidA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAGA;AAAA;AAAA;AACA;AAAA;;AACA;AACA;AAAA;AA+MA;AAAA;;AA5MA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;;AAAA;AAAA;AAAA;;;;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AA9GA;AAAA;AAAA;;AAiHA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;;;;;;;;;;ACprBA;AAAA;AAAA;AACA;;;;;AAIA;AAEA;AAAA;AAGA;AADA;AAAA;;;;;AAQA;AAAA;;;;;AAIA;AAAA;;;;;AAIA;AAAA;;;;;AAIA;AAAA;AAAA;AAAA;;;;;AAIA;;;;;;;;;;;;AASA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAKA;AAAA;;AAFA;AAAA;AAEA;AAAA;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;AAEA;AAAA;;AACA;AAAA;AAoBA;AAAA;;AAhBA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;AAAA;AAMA;AAAA;;AACA;AAAA;AAUA;AAAA;;AANA;AAAA;AAAA;AACA;AACA;AAHA;AAMA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;AAaA;AAAA;;AACA;AACA;;AAGA;AACA;;AAGA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AACA;AAAA;AAQA;AAAA;;AANA;AAAA;;AACA;AAKA;AAAA;;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;AAQA;AACA;AAAA;AAAA;AACA;AAHA;AAAA;AAMA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;;;AAGA;AAUA;AAAA;;;AANA;AACA;AACA;AACA;AAJA;AAAA;AAOA;AAAA","sourcesContent":["#ifndef __STDC_WANT_LIB_EXT1__\n# define __STDC_WANT_LIB_EXT1__ 1\n#endif\n#include <assert.h>\n#include <errno.h>\n#include <limits.h>\n#include <signal.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef HAVE_SYS_MMAN_H\n# include <sys/mman.h>\n#endif\n\n#ifdef _WIN32\n# include <windows.h>\n# include <wincrypt.h>\n#else\n# include <unistd.h>\n#endif\n\n#include \"utils.h\"\n#include \"randombytes.h\"\n\n#ifndef ENOSYS\n# define ENOSYS ENXIO\n#endif\n\n#if defined(_WIN32) && (!defined(WINAPI_FAMILY) || WINAPI_FAMILY == WINAPI_FAMILY_DESKTOP_APP)\n# define WINAPI_DESKTOP\n#endif\n\n#define CANARY_SIZE 16U\n#define GARBAGE_VALUE 0xd0\n\n#ifndef MAP_NOCORE\n# define MAP_NOCORE 0\n#endif\n#if !defined(MAP_ANON) && defined(MAP_ANONYMOUS)\n# define MAP_ANON MAP_ANONYMOUS\n#endif\n#if defined(WINAPI_DESKTOP) || (defined(MAP_ANON) && defined(HAVE_MMAP)) || defined(HAVE_POSIX_MEMALIGN)\n# define HAVE_ALIGNED_MALLOC\n#endif\n#if defined(HAVE_MPROTECT) && !(defined(PROT_NONE) && defined(PROT_READ) && defined(PROT_WRITE))\n# undef HAVE_MPROTECT\n#endif\n#if defined(HAVE_ALIGNED_MALLOC) && (defined(WINAPI_DESKTOP) || defined(HAVE_MPROTECT))\n# define HAVE_PAGE_PROTECTION\n#endif\n#if !defined(MADV_DODUMP) && defined(MADV_CORE)\n# define MADV_DODUMP   MADV_CORE\n# define MADV_DONTDUMP MADV_NOCORE\n#endif\n\nstatic size_t page_size;\nstatic unsigned char canary[CANARY_SIZE];\n\n#ifdef HAVE_WEAK_SYMBOLS\n__attribute__ ((weak)) void\n_sodium_memzero_as_a_weak_symbol_to_prevent_lto(void * const pnt, const size_t len)\n{\n    unsigned char *pnt_ = (unsigned char *) pnt;\n    size_t         i = (size_t) 0U;\n\n    while (i < len) {\n        pnt_[i++] = 0U;\n    }\n}\n#endif\n\nvoid\nsodium_memzero(void * const pnt, const size_t len)\n{\n#ifdef _WIN32\n    SecureZeroMemory(pnt, len);\n#elif defined(HAVE_MEMSET_S)\n    if (len > 0U && memset_s(pnt, (rsize_t) len, 0, (rsize_t) len) != 0) {\n        abort(); /* LCOV_EXCL_LINE */\n    }\n#elif defined(HAVE_EXPLICIT_BZERO)\n    explicit_bzero(pnt, len);\n#elif HAVE_WEAK_SYMBOLS\n    _sodium_memzero_as_a_weak_symbol_to_prevent_lto(pnt, len);\n#else\n    volatile unsigned char *volatile pnt_ =\n        (volatile unsigned char * volatile) pnt;\n    size_t i = (size_t) 0U;\n\n    while (i < len) {\n        pnt_[i++] = 0U;\n    }\n#endif\n}\n\n#ifdef HAVE_WEAK_SYMBOLS\n__attribute__ ((weak)) void\n_sodium_dummy_symbol_to_prevent_memcmp_lto(const unsigned char *b1,\n                                           const unsigned char *b2,\n                                           const size_t len)\n{\n    (void) b1;\n    (void) b2;\n    (void) len;\n}\n#endif\n\nint\nsodium_memcmp(const void * const b1_, const void * const b2_, size_t len)\n{\n#ifdef HAVE_WEAK_SYMBOLS\n    const unsigned char *b1 = (const unsigned char *) b1_;\n    const unsigned char *b2 = (const unsigned char *) b2_;\n#else\n    const volatile unsigned char *volatile b1 =\n        (const volatile unsigned char * volatile) b1_;\n    const volatile unsigned char *volatile b2 =\n        (const volatile unsigned char * volatile) b2_;\n#endif\n    size_t               i;\n    unsigned char        d = (unsigned char) 0U;\n\n#if HAVE_WEAK_SYMBOLS\n    _sodium_dummy_symbol_to_prevent_memcmp_lto(b1, b2, len);\n#endif\n    for (i = 0U; i < len; i++) {\n        d |= b1[i] ^ b2[i];\n    }\n    return (1 & ((d - 1) >> 8)) - 1;\n}\n\n#ifdef HAVE_WEAK_SYMBOLS\n__attribute__ ((weak)) void\n_sodium_dummy_symbol_to_prevent_compare_lto(const unsigned char *b1,\n                                            const unsigned char *b2,\n                                            const size_t len)\n{\n    (void) b1;\n    (void) b2;\n    (void) len;\n}\n#endif\n\nint\nsodium_compare(const unsigned char *b1_, const unsigned char *b2_, size_t len)\n{\n#ifdef HAVE_WEAK_SYMBOLS\n    const unsigned char *b1 = b1_;\n    const unsigned char *b2 = b2_;\n#else\n    const volatile unsigned char * volatile b1 =\n        (const volatile unsigned char * volatile) b1_;\n    const volatile unsigned char * volatile b2 =\n        (const volatile unsigned char * volatile) b2_;\n#endif\n    unsigned char gt = 0U;\n    unsigned char eq = 1U;\n    size_t        i;\n\n#if HAVE_WEAK_SYMBOLS\n    _sodium_dummy_symbol_to_prevent_compare_lto(b1, b2, len);\n#endif\n    i = len;\n    while (i != 0U) {\n        i--;\n        gt |= ((b2[i] - b1[i]) >> 8) & eq;\n        eq &= ((b2[i] ^ b1[i]) - 1) >> 8;\n    }\n    return (int) (gt + gt + eq) - 1;\n}\n\nint\nsodium_is_zero(const unsigned char *n, const size_t nlen)\n{\n    size_t        i;\n    unsigned char d = 0U;\n\n    for (i = 0U; i < nlen; i++) {\n        d |= n[i];\n    }\n    return 1 & ((d - 1) >> 8);\n}\n\nvoid\nsodium_increment(unsigned char *n, const size_t nlen)\n{\n    size_t        i = 0U;\n    uint_fast16_t c = 1U;\n\n#ifdef HAVE_AMD64_ASM\n    uint64_t      t64, t64_2;\n    uint32_t      t32;\n\n    if (nlen == 12U) {\n        __asm__ __volatile__(\"xorq %[t64], %[t64] \\n\"\n                             \"xorl %[t32], %[t32] \\n\"\n                             \"stc \\n\"\n                             \"adcq %[t64], (%[out]) \\n\"\n                             \"adcl %[t32], 8(%[out]) \\n\"\n                             : [t64] \"=&r\"(t64), [t32] \"=&r\" (t32)\n                             : [out] \"D\"(n)\n                             : \"memory\", \"flags\", \"cc\");\n        return;\n    } else if (nlen == 24U) {\n        __asm__ __volatile__(\"movq $1, %[t64] \\n\"\n                             \"xorq %[t64_2], %[t64_2] \\n\"\n                             \"addq %[t64], (%[out]) \\n\"\n                             \"adcq %[t64_2], 8(%[out]) \\n\"\n                             \"adcq %[t64_2], 16(%[out]) \\n\"\n                             : [t64] \"=&r\"(t64), [t64_2] \"=&r\" (t64_2)\n                             : [out] \"D\"(n)\n                             : \"memory\", \"flags\", \"cc\");\n        return;\n    } else if (nlen == 8U) {\n        __asm__ __volatile__(\"incq (%[out]) \\n\"\n                             :\n                             : [out] \"D\"(n)\n                             : \"memory\", \"flags\", \"cc\");\n        return;\n    }\n#endif\n    for (; i < nlen; i++) {\n        c += (uint_fast16_t) n[i];\n        n[i] = (unsigned char) c;\n        c >>= 8;\n    }\n}\n\nvoid\nsodium_add(unsigned char *a, const unsigned char *b, const size_t len)\n{\n    size_t        i = 0U;\n    uint_fast16_t c = 0U;\n\n#ifdef HAVE_AMD64_ASM\n    uint64_t      t64, t64_2, t64_3;\n    uint32_t      t32;\n\n    if (len == 12U) {\n        __asm__ __volatile__(\"movq (%[in]), %[t64] \\n\"\n                             \"movl 8(%[in]), %[t32] \\n\"\n                             \"addq %[t64], (%[out]) \\n\"\n                             \"adcl %[t32], 8(%[out]) \\n\"\n                             : [t64] \"=&r\"(t64), [t32] \"=&r\" (t32)\n                             : [in] \"S\"(b), [out] \"D\"(a)\n                             : \"memory\", \"flags\", \"cc\");\n        return;\n    } else if (len == 24U) {\n        __asm__ __volatile__(\"movq (%[in]), %[t64] \\n\"\n                             \"movq 8(%[in]), %[t64_2] \\n\"\n                             \"movq 16(%[in]), %[t64_3] \\n\"\n                             \"addq %[t64], (%[out]) \\n\"\n                             \"adcq %[t64_2], 8(%[out]) \\n\"\n                             \"adcq %[t64_3], 16(%[out]) \\n\"\n                             : [t64] \"=&r\"(t64), [t64_2] \"=&r\"(t64_2), [t64_3] \"=&r\"(t64_3)\n                             : [in] \"S\"(b), [out] \"D\"(a)\n                             : \"memory\", \"flags\", \"cc\");\n        return;\n    } else if (len == 8U) {\n        __asm__ __volatile__(\"movq (%[in]), %[t64] \\n\"\n                             \"addq %[t64], (%[out]) \\n\"\n                             : [t64] \"=&r\"(t64)\n                             : [in] \"S\"(b), [out] \"D\"(a)\n                             : \"memory\", \"flags\", \"cc\");\n        return;\n    }\n#endif\n    for (; i < len; i++) {\n        c += (uint_fast16_t) a[i] + (uint_fast16_t) b[i];\n        a[i] = (unsigned char) c;\n        c >>= 8;\n    }\n}\n\n/* Derived from original code by CodesInChaos */\nchar *\nsodium_bin2hex(char * const hex, const size_t hex_maxlen,\n               const unsigned char * const bin, const size_t bin_len)\n{\n    size_t       i = (size_t) 0U;\n    unsigned int x;\n    int          b;\n    int          c;\n\n    if (bin_len >= SIZE_MAX / 2 || hex_maxlen <= bin_len * 2U) {\n        abort(); /* LCOV_EXCL_LINE */\n    }\n    while (i < bin_len) {\n        c = bin[i] & 0xf;\n        b = bin[i] >> 4;\n        x = (unsigned char) (87U + c + (((c - 10U) >> 8) & ~38U)) << 8 |\n            (unsigned char) (87U + b + (((b - 10U) >> 8) & ~38U));\n        hex[i * 2U] = (char) x;\n        x >>= 8;\n        hex[i * 2U + 1U] = (char) x;\n        i++;\n    }\n    hex[i * 2U] = 0U;\n\n    return hex;\n}\n\nint\nsodium_hex2bin(unsigned char * const bin, const size_t bin_maxlen,\n               const char * const hex, const size_t hex_len,\n               const char * const ignore, size_t * const bin_len,\n               const char ** const hex_end)\n{\n    size_t        bin_pos = (size_t) 0U;\n    size_t        hex_pos = (size_t) 0U;\n    int           ret = 0;\n    unsigned char c;\n    unsigned char c_acc = 0U;\n    unsigned char c_alpha0, c_alpha;\n    unsigned char c_num0, c_num;\n    unsigned char c_val;\n    unsigned char state = 0U;\n\n    while (hex_pos < hex_len) {\n        c = (unsigned char) hex[hex_pos];\n        c_num = c ^ 48U;\n        c_num0 = (c_num - 10U) >> 8;\n        c_alpha = (c & ~32U) - 55U;\n        c_alpha0 = ((c_alpha - 10U) ^ (c_alpha - 16U)) >> 8;\n        if ((c_num0 | c_alpha0) == 0U) {\n            if (ignore != NULL && state == 0U && strchr(ignore, c) != NULL) {\n                hex_pos++;\n                continue;\n            }\n            break;\n        }\n        c_val = (c_num0 & c_num) | (c_alpha0 & c_alpha);\n        if (bin_pos >= bin_maxlen) {\n            ret = -1;\n            errno = ERANGE;\n            break;\n        }\n        if (state == 0U) {\n            c_acc = c_val * 16U;\n        } else {\n            bin[bin_pos++] = c_acc | c_val;\n        }\n        state = ~state;\n        hex_pos++;\n    }\n    if (state != 0U) {\n        hex_pos--;\n    }\n    if (hex_end != NULL) {\n        *hex_end = &hex[hex_pos];\n    }\n    if (bin_len != NULL) {\n        *bin_len = bin_pos;\n    }\n    return ret;\n}\n\nint\n_sodium_alloc_init(void)\n{\n#ifdef HAVE_ALIGNED_MALLOC\n# if defined(_SC_PAGESIZE)\n    long page_size_ = sysconf(_SC_PAGESIZE);\n    if (page_size_ > 0L) {\n        page_size = (size_t) page_size_;\n    }\n# elif defined(WINAPI_DESKTOP)\n    SYSTEM_INFO si;\n    GetSystemInfo(&si);\n    page_size = (size_t) si.dwPageSize;\n# endif\n    if (page_size < CANARY_SIZE || page_size < sizeof(size_t)) {\n        abort(); /* LCOV_EXCL_LINE */\n    }\n#endif\n    randombytes_buf(canary, sizeof canary);\n\n    return 0;\n}\n\nint\nsodium_mlock(void * const addr, const size_t len)\n{\n#if defined(MADV_DONTDUMP) && defined(HAVE_MADVISE)\n    (void) madvise(addr, len, MADV_DONTDUMP);\n#endif\n#ifdef HAVE_MLOCK\n    return mlock(addr, len);\n#elif defined(WINAPI_DESKTOP)\n    return -(VirtualLock(addr, len) == 0);\n#else\n    errno = ENOSYS;\n    return -1;\n#endif\n}\n\nint\nsodium_munlock(void * const addr, const size_t len)\n{\n    sodium_memzero(addr, len);\n#if defined(MADV_DODUMP) && defined(HAVE_MADVISE)\n    (void) madvise(addr, len, MADV_DODUMP);\n#endif\n#ifdef HAVE_MLOCK\n    return munlock(addr, len);\n#elif defined(WINAPI_DESKTOP)\n    return -(VirtualUnlock(addr, len) == 0);\n#else\n    errno = ENOSYS;\n    return -1;\n#endif\n}\n\nstatic int\n_mprotect_noaccess(void *ptr, size_t size)\n{\n#ifdef HAVE_MPROTECT\n    return mprotect(ptr, size, PROT_NONE);\n#elif defined(WINAPI_DESKTOP)\n    DWORD old;\n    return -(VirtualProtect(ptr, size, PAGE_NOACCESS, &old) == 0);\n#else\n    errno = ENOSYS;\n    return -1;\n#endif\n}\n\nstatic int\n_mprotect_readonly(void *ptr, size_t size)\n{\n#ifdef HAVE_MPROTECT\n    return mprotect(ptr, size, PROT_READ);\n#elif defined(WINAPI_DESKTOP)\n    DWORD old;\n    return -(VirtualProtect(ptr, size, PAGE_READONLY, &old) == 0);\n#else\n    errno = ENOSYS;\n    return -1;\n#endif\n}\n\nstatic int\n_mprotect_readwrite(void *ptr, size_t size)\n{\n#ifdef HAVE_MPROTECT\n    return mprotect(ptr, size, PROT_READ | PROT_WRITE);\n#elif defined(WINAPI_DESKTOP)\n    DWORD old;\n    return -(VirtualProtect(ptr, size, PAGE_READWRITE, &old) == 0);\n#else\n    errno = ENOSYS;\n    return -1;\n#endif\n}\n\n#ifdef HAVE_ALIGNED_MALLOC\n\n__attribute__ ((noreturn)) static void\n_out_of_bounds(void)\n{\n# ifdef SIGSEGV\n    raise(SIGSEGV);\n# elif defined(SIGKILL)\n    raise(SIGKILL);\n# endif\n    abort();\n} /* LCOV_EXCL_LINE */\n\nstatic inline size_t\n_page_round(const size_t size)\n{\n    const size_t page_mask = page_size - 1U;\n\n    return (size + page_mask) & ~page_mask;\n}\n\nstatic __attribute__ ((malloc)) unsigned char *\n_alloc_aligned(const size_t size)\n{\n    void *ptr;\n\n# if defined(MAP_ANON) && defined(HAVE_MMAP)\n    if ((ptr = mmap(NULL, size, PROT_READ | PROT_WRITE,\n                    MAP_ANON | MAP_PRIVATE | MAP_NOCORE, -1, 0)) == MAP_FAILED) {\n        ptr = NULL; /* LCOV_EXCL_LINE */\n    } /* LCOV_EXCL_LINE */\n# elif defined(HAVE_POSIX_MEMALIGN)\n    if (posix_memalign(&ptr, page_size, size) != 0) {\n        ptr = NULL; /* LCOV_EXCL_LINE */\n    } /* LCOV_EXCL_LINE */\n# elif defined(WINAPI_DESKTOP)\n    ptr = VirtualAlloc(NULL, size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n# else\n#  error Bug\n# endif\n    return (unsigned char *) ptr;\n}\n\nstatic void\n_free_aligned(unsigned char * const ptr, const size_t size)\n{\n# if defined(MAP_ANON) && defined(HAVE_MMAP)\n    (void) munmap(ptr, size);\n# elif defined(HAVE_POSIX_MEMALIGN)\n    free(ptr);\n# elif defined(WINAPI_DESKTOP)\n    VirtualFree(ptr, 0U, MEM_RELEASE);\n# else\n#  error Bug\n# endif\n}\n\nstatic unsigned char *\n_unprotected_ptr_from_user_ptr(void * const ptr)\n{\n    uintptr_t      unprotected_ptr_u;\n    unsigned char *canary_ptr;\n    size_t         page_mask;\n\n    canary_ptr = ((unsigned char *) ptr) - sizeof canary;\n    page_mask = page_size - 1U;\n    unprotected_ptr_u = ((uintptr_t) canary_ptr & (uintptr_t) ~page_mask);\n    if (unprotected_ptr_u <= page_size * 2U) {\n        abort(); /* LCOV_EXCL_LINE */\n    }\n    return (unsigned char *) unprotected_ptr_u;\n}\n\n#endif /* HAVE_ALIGNED_MALLOC */\n\n#ifndef HAVE_ALIGNED_MALLOC\nstatic __attribute__ ((malloc)) void *\n_sodium_malloc(const size_t size)\n{\n    return malloc(size > (size_t) 0U ? size : (size_t) 1U);\n}\n#else\nstatic __attribute__ ((malloc)) void *\n_sodium_malloc(const size_t size)\n{\n    void          *user_ptr;\n    unsigned char *base_ptr;\n    unsigned char *canary_ptr;\n    unsigned char *unprotected_ptr;\n    size_t         size_with_canary;\n    size_t         total_size;\n    size_t         unprotected_size;\n\n    if (size >= (size_t) SIZE_MAX - page_size * 4U) {\n        errno = ENOMEM;\n        return NULL;\n    }\n    if (page_size <= sizeof canary || page_size < sizeof unprotected_size) {\n        abort(); /* LCOV_EXCL_LINE */\n    }\n    size_with_canary = (sizeof canary) + size;\n    unprotected_size = _page_round(size_with_canary);\n    total_size = page_size + page_size + unprotected_size + page_size;\n    if ((base_ptr = _alloc_aligned(total_size)) == NULL) {\n        return NULL; /* LCOV_EXCL_LINE */\n    }\n    unprotected_ptr = base_ptr + page_size * 2U;\n    _mprotect_noaccess(base_ptr + page_size, page_size);\n# ifndef HAVE_PAGE_PROTECTION\n    memcpy(unprotected_ptr + unprotected_size, canary, sizeof canary);\n# endif\n    _mprotect_noaccess(unprotected_ptr + unprotected_size, page_size);\n    sodium_mlock(unprotected_ptr, unprotected_size);\n    canary_ptr = unprotected_ptr + _page_round(size_with_canary) -\n        size_with_canary;\n    user_ptr = canary_ptr + sizeof canary;\n    memcpy(canary_ptr, canary, sizeof canary);\n    memcpy(base_ptr, &unprotected_size, sizeof unprotected_size);\n    _mprotect_readonly(base_ptr, page_size);\n    assert(_unprotected_ptr_from_user_ptr(user_ptr) == unprotected_ptr);\n\n    return user_ptr;\n}\n#endif /* !HAVE_ALIGNED_MALLOC */\n\n__attribute__ ((malloc)) void *\nsodium_malloc(const size_t size)\n{\n    void *ptr;\n\n    if ((ptr = _sodium_malloc(size)) == NULL) {\n        return NULL;\n    }\n    memset(ptr, (int) GARBAGE_VALUE, size);\n\n    return ptr;\n}\n\n__attribute__ ((malloc)) void *\nsodium_allocarray(size_t count, size_t size)\n{\n    size_t total_size;\n\n    if (count > (size_t) 0U && size >= (size_t) SIZE_MAX / count) {\n        errno = ENOMEM;\n        return NULL;\n    }\n    total_size = count * size;\n\n    return sodium_malloc(total_size);\n}\n\n#ifndef HAVE_ALIGNED_MALLOC\nvoid\nsodium_free(void *ptr)\n{\n    free(ptr);\n}\n#else\nvoid\nsodium_free(void *ptr)\n{\n    unsigned char *base_ptr;\n    unsigned char *canary_ptr;\n    unsigned char *unprotected_ptr;\n    size_t         total_size;\n    size_t         unprotected_size;\n\n    if (ptr == NULL) {\n        return;\n    }\n    canary_ptr = ((unsigned char *) ptr) - sizeof canary;\n    unprotected_ptr = _unprotected_ptr_from_user_ptr(ptr);\n    base_ptr = unprotected_ptr - page_size * 2U;\n    memcpy(&unprotected_size, base_ptr, sizeof unprotected_size);\n    total_size = page_size + page_size + unprotected_size + page_size;\n    _mprotect_readwrite(base_ptr, total_size);\n    if (sodium_memcmp(canary_ptr, canary, sizeof canary) != 0) {\n        _out_of_bounds();\n    }\n# ifndef HAVE_PAGE_PROTECTION\n    if (sodium_memcmp(unprotected_ptr + unprotected_size,\n                      canary, sizeof canary) != 0) {\n        _out_of_bounds();\n    }\n# endif\n    sodium_munlock(unprotected_ptr, unprotected_size);\n    _free_aligned(base_ptr, total_size);\n}\n#endif /* HAVE_ALIGNED_MALLOC */\n\n#ifndef HAVE_PAGE_PROTECTION\nstatic int\n_sodium_mprotect(void *ptr, int (*cb)(void *ptr, size_t size))\n{\n    (void) ptr;\n    (void) cb;\n    errno = ENOSYS;\n    return -1;\n}\n#else\nstatic int\n_sodium_mprotect(void *ptr, int (*cb)(void *ptr, size_t size))\n{\n    unsigned char *base_ptr;\n    unsigned char *unprotected_ptr;\n    size_t         unprotected_size;\n\n    unprotected_ptr = _unprotected_ptr_from_user_ptr(ptr);\n    base_ptr = unprotected_ptr - page_size * 2U;\n    memcpy(&unprotected_size, base_ptr, sizeof unprotected_size);\n\n    return cb(unprotected_ptr, unprotected_size);\n}\n#endif\n\nint\nsodium_mprotect_noaccess(void *ptr)\n{\n    return _sodium_mprotect(ptr, _mprotect_noaccess);\n}\n\nint\nsodium_mprotect_readonly(void *ptr)\n{\n    return _sodium_mprotect(ptr, _mprotect_readonly);\n}\n\nint\nsodium_mprotect_readwrite(void *ptr)\n{\n    return _sodium_mprotect(ptr, _mprotect_readwrite);\n}\n","\n#include <stdlib.h>\n#include <sys/types.h>\n\n#include <assert.h>\n#include <limits.h>\n#include <stdint.h>\n\n#ifdef __EMSCRIPTEN__\n# include <emscripten.h>\n#endif\n\n#include \"randombytes.h\"\n#include \"randombytes_sysrandom.h\"\n\n#ifdef __native_client__\n# include \"randombytes_nativeclient.h\"\n#endif\n\n/* C++Builder defines a \"random\" macro */\n#undef random\n\nstatic const randombytes_implementation *implementation;\n\n#ifdef __EMSCRIPTEN__\n# define RANDOMBYTES_DEFAULT_IMPLEMENTATION NULL\n#else\n# ifdef __native_client__\n#  define RANDOMBYTES_DEFAULT_IMPLEMENTATION &randombytes_nativeclient_implementation;\n# else\n#  define RANDOMBYTES_DEFAULT_IMPLEMENTATION &randombytes_sysrandom_implementation;\n# endif\n#endif\n\nstatic void\nrandombytes_init_if_needed(void)\n{\n    if (implementation == NULL) {\n        implementation = RANDOMBYTES_DEFAULT_IMPLEMENTATION;\n        randombytes_stir();\n    }\n}\n\nint\nrandombytes_set_implementation(randombytes_implementation *impl)\n{\n    implementation = impl;\n\n    return 0;\n}\n\nconst char *\nrandombytes_implementation_name(void)\n{\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    return implementation->implementation_name();\n#else\n    return \"js\";\n#endif\n}\n\nuint32_t\nrandombytes_random(void)\n{\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    return implementation->random();\n#else\n    return EM_ASM_INT_V({\n        return Module.getRandomValue();\n    });\n#endif\n}\n\nvoid\nrandombytes_stir(void)\n{\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    if (implementation->stir != NULL) {\n        implementation->stir();\n    }\n#else\n    EM_ASM({\n        if (Module.getRandomValue === undefined) {\n            try {\n                var window_ = \"object\" === typeof window ? window : self,\n                    crypto_ = typeof window_.crypto !== \"undefined\" ? window_.crypto : window_.msCrypto,\n                    randomValuesStandard = function() {\n                        var buf = new Uint32Array(1);\n                        crypto_.getRandomValues(buf);\n                        return buf[0] >>> 0;\n                    };\n                randomValuesStandard();\n                Module.getRandomValue = randomValuesStandard;\n            } catch (e) {\n                try {\n                    var crypto = require('crypto'),\n                        randomValueNodeJS = function() {\n                            var buf = crypto.randomBytes(4);\n                            return (buf[0] << 24 | buf[1] << 16 | buf[2] << 8 | buf[3]) >>> 0;\n                        };\n                    randomValueNodeJS();\n                    Module.getRandomValue = randomValueNodeJS;\n                } catch (e) {\n                    throw 'No secure random number generator found';\n                }\n            }\n        }\n    });\n#endif\n}\n\n/*\n * randombytes_uniform() derives from OpenBSD's arc4random_uniform()\n * Copyright (c) 2008, Damien Miller <djm@openbsd.org>\n */\nuint32_t\nrandombytes_uniform(const uint32_t upper_bound)\n{\n    uint32_t min;\n    uint32_t r;\n\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    if (implementation->uniform != NULL) {\n        return implementation->uniform(upper_bound);\n    }\n#endif\n    if (upper_bound < 2) {\n        return 0;\n    }\n    min = (uint32_t) (-upper_bound % upper_bound);\n    do {\n        r = randombytes_random();\n    } while (r < min);\n\n    return r % upper_bound;\n}\n\nvoid\nrandombytes_buf(void * const buf, const size_t size)\n{\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    if (size > (size_t) 0U) {\n        implementation->buf(buf, size);\n    }\n#else\n    unsigned char *p = buf;\n    size_t         i;\n\n    for (i = (size_t) 0U; i < size; i++) {\n        p[i] = (unsigned char) randombytes_random();\n    }\n#endif\n}\n\nint\nrandombytes_close(void)\n{\n    if (implementation != NULL && implementation->close != NULL) {\n        return implementation->close();\n    }\n    return 0;\n}\n\nvoid\nrandombytes(unsigned char * const buf, const unsigned long long buf_len)\n{\n    assert(buf_len <= SIZE_MAX);\n    randombytes_buf(buf, (size_t) buf_len);\n}\n","#include <stdlib.h>\n/********************************************************************************************\r\n* SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key \r\n*       exchange providing 128 bits of quantum security and 192 bits of classical security.\r\n*\r\n*    Copyright (c) Microsoft Corporation. All rights reserved.\r\n*\r\n*\r\n* Abstract: functions for initialization and getting randomness\r\n*\r\n*********************************************************************************************/ \r\n\r\n#include \"SIDH_internal.h\"\r\n#include <malloc.h>\r\n\r\n\r\nCRYPTO_STATUS SIDH_curve_initialize(PCurveIsogenyStruct pCurveIsogeny, RandomBytes RandomBytesFunction, PCurveIsogenyStaticData pCurveIsogenyData)\r\n{ // Initialize curve isogeny structure pCurveIsogeny with static data extracted from pCurveIsogenyData.\r\n  // This needs to be called after allocating memory for \"pCurveIsogeny\" using SIDH_curve_allocate().\r\n    unsigned int i, pwords, owords;\r\n\r\n    if (is_CurveIsogenyStruct_null(pCurveIsogeny)) {\r\n        return CRYPTO_ERROR_INVALID_PARAMETER;\r\n    }\r\n\r\n    for (i = 0; i < 8; i++) {    // Copy 8-character identifier\r\n        pCurveIsogeny->CurveIsogeny[i] = pCurveIsogenyData->CurveIsogeny[i];\r\n    }\r\n    pCurveIsogeny->pwordbits = pCurveIsogenyData->pwordbits;\r\n    pCurveIsogeny->owordbits = pCurveIsogenyData->owordbits;\r\n    pCurveIsogeny->pbits = pCurveIsogenyData->pbits;\r\n    pCurveIsogeny->oAbits = pCurveIsogenyData->oAbits;\r\n    pCurveIsogeny->oBbits = pCurveIsogenyData->oBbits;\r\n    pCurveIsogeny->eB = pCurveIsogenyData->eB;\r\n    pCurveIsogeny->BigMont_A24 = pCurveIsogenyData->BigMont_A24;\r\n    pCurveIsogeny->RandomBytesFunction = RandomBytesFunction;\r\n\r\n    pwords = (pCurveIsogeny->pwordbits + RADIX - 1)/RADIX;\r\n    owords = (pCurveIsogeny->owordbits + RADIX - 1)/RADIX;\r\n    copy_words((digit_t*)pCurveIsogenyData->prime, pCurveIsogeny->prime, pwords);\r\n    copy_words((digit_t*)pCurveIsogenyData->A, pCurveIsogeny->A, pwords);\r\n    copy_words((digit_t*)pCurveIsogenyData->C, pCurveIsogeny->C, pwords);\r\n    copy_words((digit_t*)pCurveIsogenyData->Aorder, pCurveIsogeny->Aorder, owords);\r\n    copy_words((digit_t*)pCurveIsogenyData->Border, pCurveIsogeny->Border, owords);\r\n    copy_words((digit_t*)pCurveIsogenyData->PA, pCurveIsogeny->PA, 2*pwords);\r\n    copy_words((digit_t*)pCurveIsogenyData->PB, pCurveIsogeny->PB, 2*pwords);\r\n    copy_words((digit_t*)pCurveIsogenyData->BigMont_order, pCurveIsogeny->BigMont_order, pwords);\r\n    copy_words((digit_t*)pCurveIsogenyData->Montgomery_R2, pCurveIsogeny->Montgomery_R2, pwords);\r\n    copy_words((digit_t*)pCurveIsogenyData->Montgomery_pp, pCurveIsogeny->Montgomery_pp, pwords);\r\n    copy_words((digit_t*)pCurveIsogenyData->Montgomery_one, pCurveIsogeny->Montgomery_one, pwords);\r\n    \r\n    return CRYPTO_SUCCESS;\r\n}\r\n\r\n\r\nPCurveIsogenyStruct SIDH_curve_allocate(PCurveIsogenyStaticData CurveData)\r\n{ // Dynamic allocation of memory for curve isogeny structure.\r\n  // Returns NULL on error.\r\n    digit_t pbytes = (CurveData->pwordbits + 7)/8;\r\n    digit_t obytes = (CurveData->owordbits + 7)/8;\r\n    PCurveIsogenyStruct pCurveIsogeny = NULL;\r\n\r\n    pCurveIsogeny = (PCurveIsogenyStruct)calloc(1, sizeof(CurveIsogenyStruct));\r\n    pCurveIsogeny->prime = (digit_t*)calloc(1, pbytes);\r\n    pCurveIsogeny->A = (digit_t*)calloc(1, pbytes);\r\n    pCurveIsogeny->C = (digit_t*)calloc(1, pbytes);\r\n    pCurveIsogeny->Aorder = (digit_t*)calloc(1, obytes);\r\n    pCurveIsogeny->Border = (digit_t*)calloc(1, obytes);\r\n    pCurveIsogeny->PA = (digit_t*)calloc(1, 2*pbytes);\r\n    pCurveIsogeny->PB = (digit_t*)calloc(1, 2*pbytes);\r\n    pCurveIsogeny->BigMont_order = (digit_t*)calloc(1, pbytes);\r\n    pCurveIsogeny->Montgomery_R2 = (digit_t*)calloc(1, pbytes);\r\n    pCurveIsogeny->Montgomery_pp = (digit_t*)calloc(1, pbytes);\r\n    pCurveIsogeny->Montgomery_one = (digit_t*)calloc(1, pbytes);\r\n\r\n    if (is_CurveIsogenyStruct_null(pCurveIsogeny)) {\r\n        return NULL;\r\n    }\r\n    return pCurveIsogeny;\r\n}\r\n\r\n\r\nvoid SIDH_curve_free(PCurveIsogenyStruct pCurveIsogeny)\r\n{ // Free memory for curve isogeny structure\r\n\r\n    if (pCurveIsogeny != NULL)\r\n    {\r\n        if (pCurveIsogeny->prime != NULL) \r\n            free(pCurveIsogeny->prime);\r\n        if (pCurveIsogeny->A != NULL) \r\n            free(pCurveIsogeny->A);\r\n        if (pCurveIsogeny->C != NULL) \r\n            free(pCurveIsogeny->C);\r\n        if (pCurveIsogeny->Aorder != NULL) \r\n            free(pCurveIsogeny->Aorder);\r\n        if (pCurveIsogeny->Border != NULL) \r\n            free(pCurveIsogeny->Border);\r\n        if (pCurveIsogeny->PA != NULL) \r\n            free(pCurveIsogeny->PA);\r\n        if (pCurveIsogeny->PB != NULL) \r\n            free(pCurveIsogeny->PB);\r\n        if (pCurveIsogeny->BigMont_order != NULL) \r\n            free(pCurveIsogeny->BigMont_order);\r\n        if (pCurveIsogeny->Montgomery_R2 != NULL) \r\n             free(pCurveIsogeny->Montgomery_R2);\r\n        if (pCurveIsogeny->Montgomery_pp != NULL) \r\n             free(pCurveIsogeny->Montgomery_pp);\r\n        if (pCurveIsogeny->Montgomery_one != NULL) \r\n             free(pCurveIsogeny->Montgomery_one);\r\n\r\n        free(pCurveIsogeny);\r\n    }\r\n}\r\n\r\n\r\nbool is_CurveIsogenyStruct_null(PCurveIsogenyStruct pCurveIsogeny)\r\n{ // Check if curve isogeny structure is NULL\r\n\r\n    if (pCurveIsogeny == NULL || pCurveIsogeny->prime == NULL || pCurveIsogeny->A == NULL || pCurveIsogeny->C == NULL || pCurveIsogeny->Aorder == NULL || pCurveIsogeny->Border == NULL || \r\n        pCurveIsogeny->PA == NULL || pCurveIsogeny->PB == NULL || pCurveIsogeny->BigMont_order == NULL || pCurveIsogeny->Montgomery_R2 == NULL || pCurveIsogeny->Montgomery_pp == NULL || \r\n        pCurveIsogeny->Montgomery_one == NULL)\r\n    {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nconst char* SIDH_get_error_message(CRYPTO_STATUS Status)\r\n{ // Output error/success message for a given CRYPTO_STATUS\r\n    struct error_mapping {\r\n        unsigned int index;\r\n        char*        string;\r\n    } mapping[CRYPTO_STATUS_TYPE_SIZE] = {\r\n        {CRYPTO_SUCCESS, CRYPTO_MSG_SUCCESS},\r\n        {CRYPTO_ERROR, CRYPTO_MSG_ERROR},\r\n        {CRYPTO_ERROR_DURING_TEST, CRYPTO_MSG_ERROR_DURING_TEST},\r\n        {CRYPTO_ERROR_UNKNOWN, CRYPTO_MSG_ERROR_UNKNOWN},\r\n        {CRYPTO_ERROR_NOT_IMPLEMENTED, CRYPTO_MSG_ERROR_NOT_IMPLEMENTED},\r\n        {CRYPTO_ERROR_NO_MEMORY, CRYPTO_MSG_ERROR_NO_MEMORY},\r\n        {CRYPTO_ERROR_INVALID_PARAMETER, CRYPTO_MSG_ERROR_INVALID_PARAMETER},\r\n        {CRYPTO_ERROR_SHARED_KEY, CRYPTO_MSG_ERROR_SHARED_KEY},\r\n        {CRYPTO_ERROR_PUBLIC_KEY_VALIDATION, CRYPTO_MSG_ERROR_PUBLIC_KEY_VALIDATION},\r\n        {CRYPTO_ERROR_TOO_MANY_ITERATIONS, CRYPTO_MSG_ERROR_TOO_MANY_ITERATIONS}\r\n    };\r\n\r\n    if (Status >= CRYPTO_STATUS_TYPE_SIZE || mapping[Status].string == NULL) {\r\n        return \"Unrecognized CRYPTO_STATUS\";\r\n    } else {\r\n        return mapping[Status].string;\r\n    }\r\n};\r\n\r\n\r\nconst uint64_t Border_div3[NWORDS_ORDER] = { 0xEDCD718A828384F9, 0x733B35BFD4427A14, 0xF88229CF94D7CF38, 0x63C56C990C7C2AD6, 0xB858A87E8F4222C7, 0x254C9C6B525EAF5 }; \r\n\r\n\r\nCRYPTO_STATUS random_mod_order(digit_t* random_digits, unsigned int AliceOrBob, PCurveIsogenyStruct pCurveIsogeny)\r\n{ // Output random values in the range [1, order-1] in little endian format that can be used as private keys.\r\n  // It makes requests of random values with length \"oAbits\" (when AliceOrBob = 0) or \"oBbits\" (when AliceOrBob = 1) to the \"random_bytes\" function. \r\n  // The process repeats until random value is in [0, Aorder-2]  ([0, Border-2], resp.). \r\n  // If successful, the output is given in \"random_digits\" in the range [1, Aorder-1] ([1, Border-1], resp.).\r\n  // The \"random_bytes\" function, which is passed through the curve isogeny structure PCurveIsogeny, should be set up in advance using SIDH_curve_initialize().\r\n  // The caller is responsible of providing the \"random_bytes\" function passing random values as octets.\r\n    unsigned int ntry = 0, nbytes, nwords;    \r\n    digit_t t1[MAXWORDS_ORDER] = {0}, order2[MAXWORDS_ORDER] = {0};\r\n    unsigned char mask;\r\n    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN;\r\n\r\n    if (random_digits == NULL || is_CurveIsogenyStruct_null(pCurveIsogeny) || AliceOrBob > 1) {\r\n        return CRYPTO_ERROR_INVALID_PARAMETER;\r\n    }\r\n\r\n    clear_words((void*)random_digits, MAXWORDS_ORDER);     \r\n    t1[0] = 2;\r\n    if (AliceOrBob == ALICE) {\r\n        nbytes = (pCurveIsogeny->oAbits+7)/8;                  // Number of random bytes to be requested \r\n        nwords = NBITS_TO_NWORDS(pCurveIsogeny->oAbits);\r\n        mask = 0x07;                                           // Value for masking last random byte\r\n        copy_words(pCurveIsogeny->Aorder, order2, nwords);\r\n        mp_shiftr1(order2, nwords);                            // order/2\r\n        mp_sub(order2, t1, order2, nwords);                    // order2 = order/2-2\r\n    } else {\r\n        nbytes = (pCurveIsogeny->oBbits+7)/8;                    \r\n        nwords = NBITS_TO_NWORDS(pCurveIsogeny->oBbits);\r\n        mask = 0x03;                                           // Value for masking last random byte\r\n        mp_sub((digit_t*)Border_div3, t1, order2, nwords);     // order2 = order/3-2\r\n    }\r\n\r\n    do {\r\n        ntry++;\r\n        if (ntry > 100) {                                      // Max. 100 iterations to obtain random value in [0, order-2] \r\n            return CRYPTO_ERROR_TOO_MANY_ITERATIONS;\r\n        }\r\n        Status = (pCurveIsogeny->RandomBytesFunction)(nbytes, (unsigned char*)random_digits);\r\n        if (Status != CRYPTO_SUCCESS) {\r\n            return Status;\r\n        }\r\n        ((unsigned char*)random_digits)[nbytes-1] &= mask;     // Masking last byte \r\n    } while (mp_sub(order2, random_digits, t1, nwords) == 1);\r\n    \r\n    clear_words((void*)t1, MAXWORDS_ORDER);  \r\n    t1[0] = 1;\r\n    mp_add(random_digits, t1, random_digits, nwords);          \r\n    copy_words(random_digits, t1, nwords);\r\n    mp_shiftl1(random_digits, nwords);                         // Alice's output in the range [2, order-2]\r\n    if (AliceOrBob == BOB) {\r\n        mp_add(random_digits, t1, random_digits, nwords);      // Bob's output in the range [3, order-3]\r\n    }\r\n\r\n    return Status;\r\n}\r\n\r\n\r\nCRYPTO_STATUS random_BigMont_mod_order(digit_t* random_digits, PCurveIsogenyStruct pCurveIsogeny)\r\n{ // Output random values in the range [1, BigMont_order-1] in little endian format that can be used as private keys to compute scalar multiplications \r\n  // using the elliptic curve BigMont.\r\n  // It makes requests of random values with length \"BIGMONT_NBITS_ORDER\" to the \"random_bytes\" function. \r\n  // The process repeats until random value is in [0, BigMont_order-2] \r\n  // If successful, the output is given in \"random_digits\" in the range [1, BigMont_order-1].\r\n  // The \"random_bytes\" function, which is passed through the curve isogeny structure PCurveIsogeny, should be set up in advance using SIDH_curve_initialize().\r\n  // The caller is responsible of providing the \"random_bytes\" function passing random values as octets.\r\n    unsigned int ntry = 0, nbytes = (BIGMONT_NBITS_ORDER+7)/8, nwords = NBITS_TO_NWORDS(BIGMONT_NBITS_ORDER);    \r\n    digit_t t1[BIGMONT_MAXWORDS_ORDER] = {0}, order2[BIGMONT_MAXWORDS_ORDER] = {0};\r\n    unsigned char mask;\r\n    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN;\r\n\r\n    if (random_digits == NULL || is_CurveIsogenyStruct_null(pCurveIsogeny)) {\r\n        return CRYPTO_ERROR_INVALID_PARAMETER;\r\n    }\r\n\r\n    clear_words((void*)random_digits, BIGMONT_MAXWORDS_ORDER);     \r\n    t1[0] = 2;\r\n    mask = (unsigned char)(8*nbytes - BIGMONT_NBITS_ORDER);\r\n    mp_sub(pCurveIsogeny->BigMont_order, t1, order2, nwords);  // order2 = order-2\r\n    mask = ((unsigned char)-1 >> mask);                        // Value for masking last random byte\r\n\r\n    do {\r\n        ntry++;\r\n        if (ntry > 100) {                                      // Max. 100 iterations to obtain random value in [0, order-2] \r\n            return CRYPTO_ERROR_TOO_MANY_ITERATIONS;\r\n        }\r\n        Status = (pCurveIsogeny->RandomBytesFunction)(nbytes, (unsigned char*)random_digits);\r\n        if (Status != CRYPTO_SUCCESS) {\r\n            return Status;\r\n        }\r\n        ((unsigned char*)random_digits)[nbytes-1] &= mask;     // Masking last byte \r\n    } while (mp_sub(order2, random_digits, t1, nwords) == 1);\r\n    \r\n    clear_words((void*)t1, BIGMONT_MAXWORDS_ORDER);  \r\n    t1[0] = 1;\r\n    mp_add(random_digits, t1, random_digits, nwords);          // Output in the range [1, order-1]\r\n\r\n    return Status;\r\n}\r\n\r\n\r\nvoid clear_words(void* mem, digit_t nwords)\r\n{ // Clear digits from memory. \"nwords\" indicates the number of digits to be zeroed.\r\n  // This function uses the volatile type qualifier to inform the compiler not to optimize out the memory clearing.\r\n    unsigned int i;\r\n    volatile digit_t *v = mem; \r\n\r\n    for (i = 0; i < nwords; i++) {\r\n        v[i] = 0;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n","/********************************************************************************************\r\n* SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key \r\n*       exchange providing 128 bits of quantum security and 192 bits of classical security.\r\n*\r\n*    Copyright (c) Microsoft Corporation. All rights reserved.\r\n*\r\n*\r\n* Abstract: elliptic curve and isogeny functions\r\n*\r\n*********************************************************************************************/ \r\n\r\n#include \"SIDH_internal.h\"\r\n\r\n\r\nvoid j_inv(f2elm_t A, f2elm_t C, f2elm_t jinv)\r\n{ // Computes the j-invariant of a Montgomery curve with projective constant.\r\n  // Input: A,C in GF(p^2).\r\n  // Output: j=256*(A^2-3*C^2)^3/(C^4*(A^2-4*C^2)), which is j-invariant of Montgomery curve B*y^2=x^3+(A/C)*x^2+x or (equivalently) j-invariant of B'*y^2=C*x^3+A*x^2+C*x.\r\n    f2elm_t t0, t1;\r\n    \r\n    fp2sqr751_mont(A, jinv);                           // jinv = A^2        \r\n    fp2sqr751_mont(C, t1);                             // t1 = C^2\r\n    fp2add751(t1, t1, t0);                             // t0 = t1+t1\r\n    fp2sub751(jinv, t0, t0);                           // t0 = jinv-t0\r\n    fp2sub751(t0, t1, t0);                             // t0 = t0-t1\r\n    fp2sub751(t0, t1, jinv);                           // jinv = t0-t1\r\n    fp2sqr751_mont(t1, t1);                            // t1 = t1^2\r\n    fp2mul751_mont(jinv, t1, jinv);                    // jinv = jinv*t1\r\n    fp2add751(t0, t0, t0);                             // t0 = t0+t0\r\n    fp2add751(t0, t0, t0);                             // t0 = t0+t0\r\n    fp2sqr751_mont(t0, t1);                            // t1 = t0^2\r\n    fp2mul751_mont(t0, t1, t0);                        // t0 = t0*t1\r\n    fp2add751(t0, t0, t0);                             // t0 = t0+t0\r\n    fp2add751(t0, t0, t0);                             // t0 = t0+t0\r\n    fp2inv751_mont(jinv);                              // jinv = 1/jinv \r\n    fp2mul751_mont(jinv, t0, jinv);                    // jinv = t0*jinv\r\n}\r\n\r\n\r\nvoid xDBLADD(point_proj_t P, point_proj_t Q, f2elm_t xPQ, f2elm_t A24)\r\n{ // Simultaneous doubling and differential addition.\r\n  // Input: projective Montgomery points P=(XP:ZP) and Q=(XQ:ZQ) such that xP=XP/ZP and xQ=XQ/ZQ, affine difference xPQ=x(P-Q) and Montgomery curve constant A24=(A+2)/4.\r\n  // Output: projective Montgomery points P <- 2*P = (X2P:Z2P) such that x(2P)=X2P/Z2P, and Q <- P+Q = (XQP:ZQP) such that = x(Q+P)=XQP/ZQP. \r\n    f2elm_t t0, t1, t2;\r\n\r\n    fp2add751(P->X, P->Z, t0);                         // t0 = XP+ZP\r\n    fp2sub751(P->X, P->Z, t1);                         // t1 = XP-ZP\r\n    fp2sqr751_mont(t0, P->X);                          // XP = (XP+ZP)^2\r\n    fp2sub751(Q->X, Q->Z, t2);                         // t2 = XQ-ZQ\r\n    fp2add751(Q->X, Q->Z, Q->X);                       // XQ = XQ+ZQ\r\n    fp2mul751_mont(t0, t2, t0);                        // t0 = (XP+ZP)*(XQ-ZQ)\r\n    fp2sqr751_mont(t1, P->Z);                          // ZP = (XP-ZP)^2\r\n    fp2mul751_mont(t1, Q->X, t1);                      // t1 = (XP-ZP)*(XQ+ZQ)\r\n    fp2sub751(P->X, P->Z, t2);                         // t2 = (XP+ZP)^2-(XP-ZP)^2\r\n    fp2mul751_mont(P->X, P->Z, P->X);                  // XP = (XP+ZP)^2*(XP-ZP)^2\r\n    fp2mul751_mont(t2, A24, Q->X);                     // XQ = A24*[(XP+ZP)^2-(XP-ZP)^2]\r\n    fp2sub751(t0, t1, Q->Z);                           // ZQ = (XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)\r\n    fp2add751(Q->X, P->Z, P->Z);                       // ZP = A24*[(XP+ZP)^2-(XP-ZP)^2]+(XP-ZP)^2\r\n    fp2add751(t0, t1, Q->X);                           // XQ = (XP+ZP)*(XQ-ZQ)+(XP-ZP)*(XQ+ZQ)\r\n    fp2mul751_mont(P->Z, t2, P->Z);                    // ZP = [A24*[(XP+ZP)^2-(XP-ZP)^2]+(XP-ZP)^2]*[(XP+ZP)^2-(XP-ZP)^2]\r\n    fp2sqr751_mont(Q->Z, Q->Z);                        // ZQ = [(XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)]^2\r\n    fp2sqr751_mont(Q->X, Q->X);                        // XQ = [(XP+ZP)*(XQ-ZQ)+(XP-ZP)*(XQ+ZQ)]^2\r\n    fp2mul751_mont(Q->Z, xPQ, Q->Z);                   // ZQ = xPQ*[(XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)]^2\r\n}\r\n\r\n\r\nvoid xDBL(point_proj_t P, point_proj_t Q, f2elm_t A24, f2elm_t C24)\r\n{ // Doubling of a Montgomery point in projective coordinates (X:Z).\r\n  // Input: projective Montgomery x-coordinates P = (X1:Z1), where x1=X1/Z1 and Montgomery curve constant A24/C24=(A/C+2)/4.\r\n  // Output: projective Montgomery x-coordinates Q = 2*P = (X2:Z2).\r\n    f2elm_t t0, t1;\r\n    \r\n    fp2sub751(P->X, P->Z, t0);                         // t0 = X1-Z1\r\n    fp2add751(P->X, P->Z, t1);                         // t1 = X1+Z1\r\n    fp2sqr751_mont(t0, t0);                            // t0 = (X1-Z1)^2 \r\n    fp2sqr751_mont(t1, t1);                            // t1 = (X1+Z1)^2 \r\n    fp2mul751_mont(C24, t0, Q->Z);                     // Z2 = C24*(X1-Z1)^2   \r\n    fp2mul751_mont(t1, Q->Z, Q->X);                    // X2 = C24*(X1-Z1)^2*(X1+Z1)^2\r\n    fp2sub751(t1, t0, t1);                             // t1 = (X1+Z1)^2-(X1-Z1)^2 \r\n    fp2mul751_mont(A24, t1, t0);                       // t0 = A24*[(X1+Z1)^2-(X1-Z1)^2]\r\n    fp2add751(Q->Z, t0, Q->Z);                         // Z2 = A24*[(X1+Z1)^2-(X1-Z1)^2] + C24*(X1-Z1)^2\r\n    fp2mul751_mont(Q->Z, t1, Q->Z);                    // Z2 = [A24*[(X1+Z1)^2-(X1-Z1)^2] + C24*(X1-Z1)^2]*[(X1+Z1)^2-(X1-Z1)^2]\r\n}\r\n\r\n\r\nvoid xDBLe(point_proj_t P, point_proj_t Q, f2elm_t A, f2elm_t C, int e)\r\n{ // Computes [2^e](X:Z) on Montgomery curve with projective constant via e repeated doublings.\r\n  // Input: projective Montgomery x-coordinates P = (XP:ZP), such that xP=XP/ZP and Montgomery curve constant A/C.\r\n  // Output: projective Montgomery x-coordinates P <- (2^e)*P.\r\n    f2elm_t A24num, A24den;\r\n    int i;\r\n    \r\n    fp2add751(C, C, A24num);                           \r\n    fp2add751(A24num, A24num, A24den);                    \r\n    fp2add751(A24num, A, A24num); \r\n    copy_words((digit_t*)P, (digit_t*)Q, 2*2*NWORDS_FIELD);\r\n\r\n    for (i = 0; i < e; i++) {\r\n        xDBL(Q, Q, A24num, A24den);\r\n    }\r\n}\r\n\r\n\r\nvoid xADD(point_proj_t P, point_proj_t Q, f2elm_t xPQ)\r\n{ // Differential addition.\r\n  // Input: projective Montgomery points P=(XP:ZP) and Q=(XQ:ZQ) such that xP=XP/ZP and xQ=XQ/ZQ, and affine difference xPQ=x(P-Q).\r\n  // Output: projective Montgomery point P <- P+Q = (XQP:ZQP) such that = x(Q+P)=XQP/ZQP. \r\n    f2elm_t t0, t1;\r\n    \r\n    fp2add751(P->X, P->Z, t0);                         // t0 = XP+ZP\r\n    fp2sub751(P->X, P->Z, t1);                         // t1 = XP-ZP\r\n    fp2sub751(Q->X, Q->Z, P->X);                       // XP = XQ-ZQ\r\n    fp2add751(Q->X, Q->Z, P->Z);                       // ZP = XQ+ZQ\r\n    fp2mul751_mont(t0, P->X, t0);                      // t0 = (XP+ZP)*(XQ-ZQ)                           \r\n    fp2mul751_mont(t1, P->Z, t1);                      // t1 = (XP-ZP)*(XQ+ZQ)\r\n    fp2sub751(t0, t1, P->Z);                           // ZP = (XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)\r\n    fp2add751(t0, t1, P->X);                           // XP = (XP+ZP)*(XQ-ZQ)+(XP-ZP)*(XQ+ZQ)\r\n    fp2sqr751_mont(P->Z, P->Z);                        // ZP = [(XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)]^2\r\n    fp2sqr751_mont(P->X, P->X);                        // XP = [(XP+ZP)*(XQ-ZQ)+(XP-ZP)*(XQ+ZQ)]^2\r\n    fp2mul751_mont(P->Z, xPQ, P->Z);                   // ZP = xPQ*[(XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)]^2\r\n}\r\n\r\n\r\nvoid xDBL_basefield(point_basefield_proj_t P, point_basefield_proj_t Q)\r\n{ // Doubling of a Montgomery point in projective coordinates (X:Z) over the base field.\r\n  // Input: projective Montgomery x-coordinates P = (X1:Z1), where x1=X1/Z1 and Montgomery curve constant A24/C24=(A/C+2)/4.\r\n  // Output: projective Montgomery x-coordinates Q = 2*P = (X2:Z2).\r\n    felm_t t0, t1;\r\n\r\n    // NOTE: this function is fixed for A24=1, C24=2\r\n    \r\n    fpsub751(P->X, P->Z, t0);                          // t0 = X1-Z1\r\n    fpadd751(P->X, P->Z, t1);                          // t1 = X1+Z1\r\n    fpsqr751_mont(t0, t0);                             // t0 = (X1-Z1)^2 \r\n    fpsqr751_mont(t1, t1);                             // t1 = (X1+Z1)^2   \r\n    fpadd751(t0, t0, Q->Z);                            // Z2 = C24*(X1-Z1)^2 \r\n    fpmul751_mont(t1, Q->Z, Q->X);                     // X2 = C24*(X1-Z1)^2*(X1+Z1)^2\r\n    fpsub751(t1, t0, t1);                              // t1 = (X1+Z1)^2-(X1-Z1)^2 \r\n    fpadd751(Q->Z, t1, Q->Z);                          // Z2 = A24*[(X1+Z1)^2-(X1-Z1)^2] + C24*(X1-Z1)^2\r\n    fpmul751_mont(Q->Z, t1, Q->Z);                     // Z2 = [A24*[(X1+Z1)^2-(X1-Z1)^2] + C24*(X1-Z1)^2]*[(X1+Z1)^2-(X1-Z1)^2]\r\n}\r\n\r\n\r\nvoid xDBLADD_basefield(point_basefield_proj_t P, point_basefield_proj_t Q, felm_t xPQ, felm_t A24)\r\n{ // Simultaneous doubling and differential addition over the base field.\r\n  // Input: projective Montgomery points P=(XP:ZP) and Q=(XQ:ZQ) such that xP=XP/ZP and xQ=XQ/ZQ, affine difference xPQ=x(P-Q) and Montgomery curve constant A24=(A+2)/4.\r\n  // Output: projective Montgomery points P <- 2*P = (X2P:Z2P) such that x(2P)=X2P/Z2P, and Q <- P+Q = (XQP:ZQP) such that = x(Q+P)=XQP/ZQP. \r\n    felm_t t0, t1, t2;\r\n\r\n    // NOTE: this function is fixed for C24=2\r\n\r\n    fpadd751(P->X, P->Z, t0);                          // t0 = XP+ZP\r\n    fpsub751(P->X, P->Z, t1);                          // t1 = XP-ZP\r\n    fpsqr751_mont(t0, P->X);                           // XP = (XP+ZP)^2\r\n    fpsub751(Q->X, Q->Z, t2);                          // t2 = XQ-ZQ\r\n    fpadd751(Q->X, Q->Z, Q->X);                        // XQ = XQ+ZQ\r\n    fpmul751_mont(t0, t2, t0);                         // t0 = (XP+ZP)*(XQ-ZQ)\r\n    fpsqr751_mont(t1, P->Z);                           // ZP = (XP-ZP)^2\r\n    fpmul751_mont(t1, Q->X, t1);                       // t1 = (XP-ZP)*(XQ+ZQ)\r\n    fpsub751(P->X, P->Z, t2);                          // t2 = (XP+ZP)^2-(XP-ZP)^2\r\n\r\n    if (A24[0] == 1) {\r\n        fpadd751(P->Z, P->Z, P->Z);                    // ZP = C24*(XP-ZP)^2\r\n        fpmul751_mont(P->X, P->Z, P->X);               // XP = C24*(XP+ZP)^2*(XP-ZP)^2\r\n        fpadd751(t2, P->Z, P->Z);                      // ZP = A24*[(XP+ZP)^2-(XP-ZP)^2]+C24*(XP-ZP)^2\r\n    } else {\r\n        fpmul751_mont(P->X, P->Z, P->X);               // XP = (XP+ZP)^2*(XP-ZP)^2\r\n        fpmul751_mont(A24, t2, Q->X);                  // XQ = A24*[(XP+ZP)^2-(XP-ZP)^2]\r\n        fpadd751(P->Z, Q->X, P->Z);                    // ZP = A24*[(XP+ZP)^2-(XP-ZP)^2]+C24*(XP-ZP)^2\r\n    }\r\n    \r\n    fpsub751(t0, t1, Q->Z);                            // ZQ = (XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)\r\n    fpadd751(t0, t1, Q->X);                            // XQ = (XP+ZP)*(XQ-ZQ)+(XP-ZP)*(XQ+ZQ)\r\n    fpmul751_mont(P->Z, t2, P->Z);                     // ZP = [A24*[(XP+ZP)^2-(XP-ZP)^2]+C24*(XP-ZP)^2]*[(XP+ZP)^2-(XP-ZP)^2]\r\n    fpsqr751_mont(Q->Z, Q->Z);                         // ZQ = [(XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)]^2\r\n    fpsqr751_mont(Q->X, Q->X);                         // XQ = [(XP+ZP)*(XQ-ZQ)+(XP-ZP)*(XQ+ZQ)]^2\r\n    fpmul751_mont(Q->Z, xPQ, Q->Z);                    // ZQ = xPQ*[(XP+ZP)*(XQ-ZQ)-(XP-ZP)*(XQ+ZQ)]^2\r\n}\r\n\r\n\r\nvoid ladder(felm_t x, digit_t* m, point_basefield_proj_t P, point_basefield_proj_t Q, felm_t A24, unsigned int order_bits, unsigned int order_fullbits, PCurveIsogenyStruct CurveIsogeny)\r\n{ // The Montgomery ladder\r\n  // Inputs: the affine x-coordinate of a point P on E: B*y^2=x^3+A*x^2+x, \r\n  //         scalar m\r\n  //         curve constant A24 = (A+2)/4\r\n  //         order_bits = subgroup order bitlength\r\n  //         order_fullbits = smallest multiple of 32 larger than the order bitlength\r\n  // Output: Q = m*(x:1)\r\n  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().\r\n    unsigned int bit = 0, owords = NBITS_TO_NWORDS(order_fullbits);\r\n    digit_t mask;\r\n    int i;\r\n\r\n    // Initializing with the points (1:0) and (x:1)\r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)P->X);\r\n    fpzero751(P->Z);\r\n    fpcopy751(x, Q->X);\r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)Q->Z);\r\n\r\n    for (i = order_fullbits-order_bits; i > 0; i--) {\r\n        mp_shiftl1(m, owords);\r\n    }\r\n    \r\n    for (i = order_bits; i > 0; i--) {\r\n        bit = (unsigned int)(m[owords-1] >> (RADIX-1));\r\n        mp_shiftl1(m, owords);\r\n        mask = 0-(digit_t)bit;\r\n\r\n        swap_points_basefield(P, Q, mask);\r\n        xDBLADD_basefield(P, Q, x, A24);           // If bit=0 then P <- 2*P and Q <- P+Q, \r\n        swap_points_basefield(P, Q, mask);         // else if bit=1 then Q <- 2*Q and P <- P+Q\r\n    }\r\n}\r\n\r\n\r\nCRYPTO_STATUS BigMont_ladder(unsigned char* x, digit_t* m, unsigned char* xout, PCurveIsogenyStruct CurveIsogeny)\r\n{ // BigMont's scalar multiplication using the Montgomery ladder\r\n  // Inputs: x, the affine x-coordinate of a point P on BigMont: y^2=x^3+A*x^2+x, \r\n  //         scalar m.\r\n  // Output: xout, the affine x-coordinate of m*(x:1)\r\n  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().\r\n    point_basefield_proj_t P1, P2;\r\n    digit_t scalar[BIGMONT_NWORDS_ORDER];\r\n    felm_t X, A24 = {0};\r\n\r\n    A24[0] = (digit_t)CurveIsogeny->BigMont_A24; \r\n    to_mont(A24, A24);                               // Conversion to Montgomery representation\r\n    to_mont((digit_t*)x, X);\r\n    \r\n    copy_words(m, scalar, BIGMONT_NWORDS_ORDER);\r\n    ladder(X, scalar, P1, P2, A24, BIGMONT_NBITS_ORDER, BIGMONT_MAXBITS_ORDER, CurveIsogeny);\r\n\r\n    fpinv751_mont(P1->Z);\r\n    fpmul751_mont(P1->X, P1->Z, (digit_t*)xout);\r\n    from_mont((digit_t*)xout, (digit_t*)xout);       // Conversion to standard representation\r\n\r\n    return CRYPTO_SUCCESS;\r\n}\r\n\r\n\r\nCRYPTO_STATUS secret_pt(point_basefield_t P, digit_t* m, unsigned int AliceOrBob, point_proj_t R, PCurveIsogenyStruct CurveIsogeny)\r\n{ // Computes key generation entirely in the base field by exploiting a 1-dimensional Montgomery ladder in the trace zero subgroup and \r\n  // recovering the y-coordinate for the addition. All operations in the base field GF(p).\r\n  // Input:  The scalar m, point P = (x,y) on E in the base field subgroup and Q = (x1,y1*i) on E in the trace-zero subgroup. \r\n  //         x,y,x1,y1 are all in the base field.          \r\n  // Output: R = (RX0+RX1*i)/RZ0 (the x-coordinate of P+[m]Q).\r\n    unsigned int nbits;\r\n    point_basefield_t Q;\r\n    point_basefield_proj_t S, T;\r\n    digit_t *X0 = (digit_t*)S->X, *Z0 = (digit_t*)S->Z, *X1 = (digit_t*)T->X, *Z1 = (digit_t*)T->Z;\r\n    digit_t *x  = (digit_t*)P->x, *y  = (digit_t*)P->y, *x1 = (digit_t*)Q->x, *y1 = (digit_t*)Q->y;\r\n    digit_t scalar[NWORDS_ORDER];\r\n    felm_t t0, t1, t2, A24 = {0};\r\n    digit_t *RX0 = (digit_t*)R->X[0], *RX1 = (digit_t*)R->X[1], *RZ0 = (digit_t*)R->Z[0], *RZ1 = (digit_t*)R->Z[1];\r\n\r\n    fpcopy751(P->x, Q->x);                         // Q = (-XP,YP)\r\n    fpcopy751(P->y, Q->y);\r\n    fpneg751(Q->x);\r\n\r\n    if (AliceOrBob == ALICE) {\r\n        nbits = CurveIsogeny->oAbits;\r\n    } else if (AliceOrBob == BOB) {\r\n        nbits = CurveIsogeny->oBbits;\r\n    } else {\r\n        return CRYPTO_ERROR_INVALID_PARAMETER;\r\n    }\r\n        \r\n    // Setting curve constant to one (in standard representation), used in xDBLADD_basefield() in the ladder computation\r\n    A24[0] = 1;\r\n    copy_words(m, scalar, NWORDS_ORDER);\r\n    ladder(Q->x, scalar, S, T, A24, nbits, CurveIsogeny->owordbits, CurveIsogeny);\r\n    \r\n    //RX0 := (2*y*y1*Z0^2*Z1 + Z1*(X0*x1+Z0)*(X0+x1*Z0) - X1*(X0-x1*Z0)^2)*(2*y*y1*Z0^2*Z1 - Z1*(X0*x1+Z0)*(X0+x1*Z0) + X1*(X0-x1*Z0)^2) - 4*y1^2*Z0*Z1^2*(X0+x*Z0)*(X0-x*Z0)^2;\r\n    //RX1 := 4*y*y1*Z0^2*Z1*(Z1*(X0*x1+Z0)*(X0+x1*Z0) - X1*(X0-x1*Z0)^2);\r\n    //RZ0 := 4*y1^2*Z0^2*Z1^2*(X0-x*Z0)^2;\r\n\r\n    fpmul751_mont(x1, Z0, RX1);\r\n    fpmul751_mont(X0, x1, RX0);\r\n    fpsub751(X0, RX1, t0);\r\n    fpadd751(X0, RX1, RX1);\r\n    fpsqr751_mont(t0, t0);\r\n    fpadd751(RX0, Z0, RX0);\r\n    fpmul751_mont(t0, X1, t0);\r\n    fpmul751_mont(RX0, RX1, RX0);\r\n    fpmul751_mont(y1, Z1, t2);\r\n    fpmul751_mont(y, Z0, t1);\r\n    fpadd751(t2, t2, t2);\r\n    fpmul751_mont(t2, Z0, RX1);\r\n    fpmul751_mont(RX0, Z1, RX0);\r\n    fpsub751(RX0, t0, RX0);\r\n    fpmul751_mont(t1, RX1, t1);\r\n    fpsqr751_mont(RX1, t0);\r\n    fpmul751_mont(t2, RX1, t2);\r\n    fpmul751_mont(t1, RX0, RX1);\r\n    fpadd751(t1, RX0, RZ0);\r\n    fpadd751(RX1, RX1, RX1);\r\n    fpsub751(t1, RX0, t1);\r\n    fpmul751_mont(x, Z0, RX0);\r\n    fpmul751_mont(t1, RZ0, t1);\r\n    fpsub751(X0, RX0, RZ0);\r\n    fpadd751(X0, RX0, RX0);\r\n    fpsqr751_mont(RZ0, RZ0);\r\n    fpmul751_mont(t2, RX0, t2);\r\n    fpmul751_mont(t2, RZ0, t2);\r\n    fpmul751_mont(RZ0, t0, RZ0);\r\n    fpsub751(t1, t2, RX0);\r\n    fpzero751(RZ1);\r\n\r\n    return CRYPTO_SUCCESS;\r\n}\r\n\r\n\r\nCRYPTO_STATUS ladder_3_pt(f2elm_t xP, f2elm_t xQ, f2elm_t xPQ, digit_t* m, unsigned int AliceOrBob, point_proj_t W, f2elm_t A, PCurveIsogenyStruct CurveIsogeny)\r\n{ // Computes P+[m]Q via x-only arithmetic. Algorithm by De Feo, Jao and Plut.\r\n  // Input:  three affine points xP,xQ,xPQ and Montgomery constant A.\r\n  // Output: projective Montgomery x-coordinates of x(P+[m]Q)=WX/WZ\r\n    point_proj_t U = {0}, V = {0};\r\n    f2elm_t A24, A24num, constant1 = {0}, constant2;\r\n    felm_t temp_scalar;\r\n    unsigned int bit = 0, nbits, fullbits = CurveIsogeny->owordbits;\r\n    digit_t mask;\r\n    int i;\r\n\r\n    if (AliceOrBob == ALICE) {\r\n        nbits = CurveIsogeny->oAbits;\r\n    } else if (AliceOrBob == BOB) {\r\n        nbits = CurveIsogeny->oBbits;\r\n    } else {\r\n        return CRYPTO_ERROR_INVALID_PARAMETER;\r\n    }\r\n   \r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, constant1[0]);\r\n    fp2add751(constant1, constant1, constant1);                  // constant = 2\r\n    fp2add751(A, constant1, A24num);\r\n    fp2div2_751(A24num, A24);  \r\n    fp2div2_751(A24, A24);\r\n    \r\n    // Initializing with the points (1:0), (xQ:1) and (xP:1)\r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)U->X);\r\n    fp2copy751(xQ, V->X);\r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)V->Z);\r\n    fp2copy751(xP, W->X);\r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)W->Z);\r\n    fpzero751(W->Z[1]);\r\n    fpcopy751(m, temp_scalar);\r\n    \r\n    for (i = fullbits-nbits; i > 0; i--) {\r\n        mp_shiftl1(temp_scalar, NWORDS_ORDER);\r\n    }\r\n    \r\n    for (i = nbits; i > 0; i--) {\r\n        bit = (unsigned int)(temp_scalar[NWORDS_ORDER-1] >> (RADIX-1));\r\n        mp_shiftl1(temp_scalar, NWORDS_ORDER);\r\n        mask = 0 - (digit_t)bit;\r\n\r\n        swap_points(W, U, mask);\r\n        swap_points(U, V, mask);\r\n        select_f2elm(xP, xQ, constant1, mask);\r\n        select_f2elm(xQ, xPQ, constant2, mask);\r\n        xADD(W, U, constant1);                     // If bit=0 then W <- W+U, U <- 2*U and V <- U+V, \r\n        xDBLADD(U, V, constant2, A24);             // else if bit=1 then U <- U+V, V <- 2*V and W <- V+W\r\n        swap_points(U, V, mask);\r\n        swap_points(W, U, mask);\r\n    }\r\n\r\n    return CRYPTO_SUCCESS;\r\n}\r\n\r\n\r\nvoid get_4_isog(point_proj_t P, f2elm_t A, f2elm_t C, f2elm_t* coeff)\r\n{ // Computes the corresponding 4-isogeny of a projective Montgomery point (X4:Z4) of order 4.\r\n  // Input:  projective point of order four P = (X4:Z4).\r\n  // Output: the 4-isogenous Montgomery curve with projective coefficient A/C and the 5 coefficients \r\n  //         that are used to evaluate the isogeny at a point in eval_4_isog().\r\n    \r\n    fp2add751(P->X, P->Z, coeff[0]);                   // coeff[0] = X4+Z4\r\n    fp2sqr751_mont(P->X, coeff[3]);                    // coeff[3] = X4^2\r\n    fp2sqr751_mont(P->Z, coeff[4]);                    // coeff[4] = Z4^2\r\n    fp2sqr751_mont(coeff[0], coeff[0]);                // coeff[0] = (X4+Z4)^2\r\n    fp2add751(coeff[3], coeff[4], coeff[1]);           // coeff[1] = X4^2+Z4^2\r\n    fp2sub751(coeff[3], coeff[4], coeff[2]);           // coeff[2] = X4^2-Z4^2\r\n    fp2sqr751_mont(coeff[3], coeff[3]);                // coeff[3] = X4^4\r\n    fp2sqr751_mont(coeff[4], coeff[4]);                // coeff[4] = Z4^4\r\n    fp2add751(coeff[3], coeff[3], A);                  // A = 2*X4^4\r\n    fp2sub751(coeff[0], coeff[1], coeff[0]);           // coeff[0] = 2*X4*Z4 = (X4+Z4)^2 - (X4^2+Z4^2)\r\n    fp2sub751(A, coeff[4], A);                         // A = 2*X4^4-Z4^4\r\n    fp2copy751(coeff[4], C);                           // C = Z4^4\r\n    fp2add751(A, A, A);                                // A = 2(2*X4^4-Z4^4)\r\n}\r\n\r\n\r\nvoid eval_4_isog(point_proj_t P, f2elm_t* coeff)\r\n{ // Evaluates the isogeny at the point (X:Z) in the domain of the isogeny, given a 4-isogeny phi defined \r\n  // by the 5 coefficients in coeff (computed in the function four_isogeny_from_projective_kernel()).\r\n  // Inputs: the coefficients defining the isogeny, and the projective point P = (X:Z).\r\n  // Output: the projective point P = phi(P) = (X:Z) in the codomain. \r\n    f2elm_t t0, t1;\r\n\r\n    fp2mul751_mont(P->X, coeff[0], P->X);              // X = coeff[0]*X\r\n    fp2mul751_mont(P->Z, coeff[1], t0);                // t0 = coeff[1]*Z\r\n    fp2sub751(P->X, t0, P->X);                         // X = X-t0\r\n    fp2mul751_mont(P->Z, coeff[2], P->Z);              // Z = coeff[2]*Z\r\n    fp2sub751(P->X, P->Z, t0);                         // t0 = X-Z\r\n    fp2mul751_mont(P->Z, P->X, P->Z);                  // Z = X*Z\r\n    fp2sqr751_mont(t0, t0);                            // t0 = t0^2\r\n    fp2add751(P->Z, P->Z, P->Z);                       // Z = Z+Z\r\n    fp2add751(P->Z, P->Z, P->Z);                       // Z = Z+Z\r\n    fp2add751(P->Z, t0, P->X);                         // X = t0+Z\r\n    fp2mul751_mont(P->Z, t0, P->Z);                    // Z = t0*Z\r\n    fp2mul751_mont(P->Z, coeff[4], P->Z);              // Z = coeff[4]*Z\r\n    fp2mul751_mont(t0, coeff[4], t0);                  // t0 = t0*coeff[4]\r\n    fp2mul751_mont(P->X, coeff[3], t1);                // t1 = X*coeff[3]\r\n    fp2sub751(t0, t1, t0);                             // t0 = t0-t1\r\n    fp2mul751_mont(P->X, t0, P->X);                    // X = X*t0\r\n}\r\n\r\n\r\nvoid first_4_isog(point_proj_t P, f2elm_t A, f2elm_t Aout, f2elm_t Cout, PCurveIsogenyStruct CurveIsogeny)\r\n{ // Computes first 4-isogeny computed by Alice.\r\n  // Inputs: projective point P = (X4:Z4) and curve constant A.\r\n  // Output: the projective point P = (X4:Z4) in the codomain and isogenous curve constant Aout/Cout.  \r\n    f2elm_t t0 = {0}, t1, t2;\r\n    \r\n    fpcopy751(CurveIsogeny->Montgomery_one, t0[0]); \r\n    fpadd751(t0[0], t0[0], t0[0]);                     // t0 = 2 (in Montgomery domain)\r\n    fp2sub751(A, t0, Cout);                            // Cout = A-2\r\n    fpadd751(t0[0], t0[0], t1[0]);                     \r\n    fpadd751(t0[0], t1[0], t0[0]);                     // t0 = 6 (in Montgomery domain)\r\n    fp2add751(P->X, P->Z, t1);                         // t1 = X+Z\r\n    fp2sub751(P->X, P->Z, t2);                         // t2 = X-Z\r\n    fp2sqr751_mont(t1, t1);                            // t1 = (X+Z)^2\r\n    fp2add751(A, t0, Aout);                            // A = A+6\r\n    fp2mul751_mont(P->X, P->Z, P->Z);                  // Z = X*Z\r\n    fp2neg751(P->Z);                                   // Z = -X*Z\r\n    fp2sqr751_mont(t2, t2);                            // t2 = (X-Z)^2\r\n    fp2mul751_mont(P->Z, Cout, P->Z);                  // Z = -C*X*Z\r\n    fp2add751(Aout, Aout, Aout);                       // Aout = 2*A+12\r\n    fp2sub751(t1, P->Z, P->X);                         // X = (X+Z)^2+C*X*Z\r\n    fp2mul751_mont(P->Z, t2, P->Z);                    // Z = -C*X*Z*(X-Z)^2\r\n    fp2mul751_mont(P->X, t1, P->X);                    // X = (X+Z)^2*[(X+Z)^2+C*X*Z]\r\n}\r\n\r\n\r\nvoid xTPL(point_proj_t P, point_proj_t Q, f2elm_t A, f2elm_t C)\r\n{ // Tripling of a Montgomery point in projective coordinates (X:Z).\r\n  // Input: projective Montgomery x-coordinates P = (X:Z), where x=X/Z and Montgomery curve constant A4=4*A.\r\n  // Output: projective Montgomery x-coordinates Q = 3*P = (X3:Z3).\r\n    f2elm_t t0, t1, t2, t3, t4, t5;\r\n    \r\n    fp2add751(P->X, P->Z, t2);                         // t2 = X+Z\r\n    fp2sqr751_mont(P->X, t0);                          // t0 = X^2\r\n    fp2sqr751_mont(P->Z, t1);                          // t1 = Z^2\r\n    fp2sqr751_mont(t2, t2);                            // t2 = (X+Z)^2\r\n    fp2mul751_mont(t0, C, t3);                         // t3 = C*X^2\r\n    fp2sub751(t2, t0, t2);                             // t2 = (X+Z)^2-X^2\r\n    fp2mul751_mont(t1, C, t4);                         // t4 = C*Z^2\r\n    fp2sub751(t2, t1, t2);                             // t2 = 2XZ = (X+Z)^2-X^2-Z^2\r\n    fp2add751(t3, t4, t5);                             // t5 = C*X^2+C*Z^2\r\n    fp2mul751_mont(t2, A, t2);                         // t2 = 2AXZ\r\n    fp2add751(t3, t3, t3);                             // t3 = 2C*X^2 \r\n    fp2add751(t4, t4, t4);                             // t4 = 2C*Z^2\r\n    fp2add751(t3, t2, t3);                             // t3 = 2C*X^2+2AXZ\r\n    fp2add751(t4, t2, t4);                             // t4 = 2C*Z^2+2AXZ\r\n    fp2add751(t3, t5, t3);                             // t3 = 2C*X^2+2AXZ + C*X^2+C*Z^2\r\n    fp2add751(t4, t5, t4);                             // t4 = 2C*Z^2+2AXZ + C*X^2+C*Z^2\r\n    fp2sub751(t0, t1, t2);                             // t2 = X^2-Z^2\r\n    fp2add751(t0, t0, t0);                             // t0 = 2X^2\r\n    fp2add751(t1, t1, t1);                             // t1 = 2Z^2\r\n    fp2mul751_mont(t2, t5, t2);                        // t2 = (X^2-Z^2)(C*X^2+C*Z^2)\r\n    fp2mul751_mont(t1, t3, t1);                        // t1 = 2Z^2*[2C*X^2+2AXZ+C*X^2+C*Z^2]\r\n    fp2mul751_mont(t0, t4, t0);                        // t0 = 2X^2*[2C*Z^2+2AXZ+C*X^2+C*Z^2]\r\n    fp2sub751(t1, t2, t1);                             // t1 = 2Z^2*[2C*X^2+2AXZ+C*X^2+C*Z^2] - (X^2-Z^2)(C*X^2+C*Z^2)\r\n    fp2add751(t0, t2, t0);                             // t0 = 2X^2*[2C*Z^2+2AXZ+C*X^2+C*Z^2] + (X^2-Z^2)(C*X^2+C*Z^2)\r\n    fp2sqr751_mont(t1, t1);                            // t1 = [2Z^2*[2C*X^2+2AXZ+C*X^2+C*Z^2] - (X^2-Z^2)(C*X^2+C*Z^2)]^2\r\n    fp2sqr751_mont(t0, t0);                            // t0 = [2X^2*[2C*Z^2+2AXZ+C*X^2+C*Z^2] + (X^2-Z^2)(C*X^2+C*Z^2)]^2\r\n    fp2mul751_mont(P->X, t1, Q->X);                    // X3 = X*[2Z^2*[2C*X^2+2AXZ+C*X^2+C*Z^2] - (X^2-Z^2)(C*X^2+C*Z^2)]^2\r\n    fp2mul751_mont(P->Z, t0, Q->Z);                    // Z3 = Z*[2X^2*[2C*Z^2+2AXZ+C*X^2+C*Z^2] + (X^2-Z^2)(C*X^2+C*Z^2)]^2\r\n}\r\n\r\n\r\nvoid xTPLe(point_proj_t P, point_proj_t Q, f2elm_t A, f2elm_t C, int e)\r\n{ // Computes [3^e](X:Z) on Montgomery curve with projective constant via e repeated triplings.\r\n  // Input: projective Montgomery x-coordinates P = (XP:ZP), such that xP=XP/ZP and Montgomery curve constant A/C.\r\n  // Output: projective Montgomery x-coordinates P <- (3^e)*P.\r\n    int i;\r\n      \r\n    copy_words((digit_t*)P, (digit_t*)Q, 2*2*NWORDS_FIELD);\r\n\r\n    for (i = 0; i < e; i++) {\r\n        xTPL(Q, Q, A, C);\r\n    }\r\n}\r\n\r\n\r\nvoid get_3_isog(point_proj_t P, f2elm_t A, f2elm_t C)\r\n{ // Computes the corresponding 3-isogeny of a projective Montgomery point (X3:Z3) of order 3.\r\n  // Input:  projective point of order three P = (X3:Z3).\r\n  // Output: the 3-isogenous Montgomery curve with projective coefficient A/C. \r\n    f2elm_t t0, t1;\r\n\r\n    fp2sqr751_mont(P->X, t0);                          // t0 = X^2\r\n    fp2add751(t0, t0, t1);                             // t1 = 2*t0\r\n    fp2add751(t0, t1, t0);                             // t0 = t0+t1\r\n    fp2sqr751_mont(P->Z, t1);                          // t1 = Z^2\r\n    fp2sqr751_mont(t1, A);                             // A = t1^2\r\n    fp2add751(t1, t1, t1);                             // t1 = 2*t1\r\n    fp2add751(t1, t1, C);                              // C = 2*t1\r\n    fp2sub751(t0, t1, t1);                             // t1 = t0-t1\r\n    fp2mul751_mont(t0, t1, t1);                        // t1 = t0*t1\r\n    fp2sub751(A, t1, A);                               // A = A-t1 \r\n    fp2sub751(A, t1, A);                               // A = A-t1 \r\n    fp2sub751(A, t1, A);                               // A = A-t1     \r\n    fp2mul751_mont(P->X, P->Z, t1);                    // t1 = X*Z    \r\n    fp2mul751_mont(C, t1, C);                          // C = C*t1\r\n}\r\n\r\n\r\nvoid eval_3_isog(point_proj_t P, point_proj_t Q)\r\n{ // Computes the 3-isogeny R=phi(X:Z), given projective point (X3:Z3) of order 3 on a Montgomery curve and a point P = (X:Z).\r\n  // Inputs: projective points P = (X3:Z3) and Q = (X:Z).\r\n  // Output: the projective point R = phi(Q) = (XX:ZZ). \r\n    f2elm_t t0, t1, t2;\r\n\r\n    fp2mul751_mont(P->X, Q->X, t0);                  // t0 = X3*X\r\n    fp2mul751_mont(P->Z, Q->X, t1);                  // t1 = Z3*X\r\n    fp2mul751_mont(P->Z, Q->Z, t2);                  // t2 = Z3*Z\r\n    fp2sub751(t0, t2, t0);                           // t0 = X3*X-Z3*Z          \r\n    fp2mul751_mont(P->X, Q->Z, t2);                  // t2 = X3*Z\r\n    fp2sub751(t1, t2, t1);                           // t1 = Z3*X-X3*Z\r\n    fp2sqr751_mont(t0, t0);                          // t0 = (X3*X-Z3*Z)^2\r\n    fp2sqr751_mont(t1, t1);                          // t1 = (Z3*X-X3*Z)^2\r\n    fp2mul751_mont(Q->X, t0, Q->X);                  // X = X*(X3*X-Z3*Z)^2        \r\n    fp2mul751_mont(Q->Z, t1, Q->Z);                  // Z = Z*(Z3*X-X3*Z)^2\r\n}\r\n\r\n\r\nvoid inv_4_way(f2elm_t z1, f2elm_t z2, f2elm_t z3, f2elm_t z4)\r\n{ // 4-way simultaneous inversion\r\n  // Input:  z1,z2,z3,z4\r\n  // Output: 1/z1,1/z2,1/z3,1/z4 (override inputs).\r\n    f2elm_t t0, t1, t2;\r\n\r\n    fp2mul751_mont(z1, z2, t0);                      // t0 = z1*z2\r\n    fp2mul751_mont(z3, z4, t1);                      // t1 = z3*z4\r\n    fp2mul751_mont(t0, t1, t2);                      // t2 = z1*z2*z3*z4\r\n    fp2inv751_mont(t2);                              // t2 = 1/(z1*z2*z3*z4)\r\n    fp2mul751_mont(t0, t2, t0);                      // t0 = 1/(z3*z4) \r\n    fp2mul751_mont(t1, t2, t1);                      // t1 = 1/(z1*z2) \r\n    fp2mul751_mont(t0, z3, t2);                      // t2 = 1/z4\r\n    fp2mul751_mont(t0, z4, z3);                      // z3 = 1/z3\r\n    fp2copy751(t2, z4);                              // z4 = 1/z4\r\n    fp2mul751_mont(z1, t1, t2);                      // t2 = 1/z2\r\n    fp2mul751_mont(z2, t1, z1);                      // z1 = 1/z1\r\n    fp2copy751(t2, z2);                              // z2 = 1/z2\r\n}\r\n\r\n\r\nvoid distort_and_diff(felm_t xP, point_proj_t D, PCurveIsogenyStruct CurveIsogeny)\r\n{ // Computing the point (x(Q-P),z(Q-P))\r\n  // Input:  coordinate xP of point P=(xP,yP)\r\n  // Output: the point D = (x(Q-P),z(Q-P)), where Q=tau(P).\r\n    felm_t one;\r\n\r\n    fpcopy751(CurveIsogeny->Montgomery_one, one);\r\n    fpsqr751_mont(xP, D->X[0]);\t                     // XD = xP^2\r\n    fpadd751(D->X[0], one, D->X[0]);                 // XD = XD+1\r\n    fpcopy751(D->X[0], D->X[1]);                     // XD = XD*i\r\n    fpzero751(D->X[0]);          \r\n    fpadd751(xP, xP, D->Z[0]);                       // ZD = xP+xP\r\n}","/********************************************************************************************\r\n* SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key \r\n*       exchange providing 128 bits of quantum security and 192 bits of classical security.\r\n*\r\n*    Copyright (c) Microsoft Corporation. All rights reserved.\r\n*\r\n*\r\n* Abstract: core functions over GF(p751^2) and field operations over the prime p751\r\n*\r\n*********************************************************************************************/ \r\n\r\n#include \"SIDH_internal.h\"\r\n    \r\n\r\n// Global constants          \r\nconst uint64_t p751[NWORDS_FIELD]          = { 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xEEAFFFFFFFFFFFFF,\r\n                                               0xE3EC968549F878A8, 0xDA959B1A13F7CC76, 0x084E9867D6EBE876, 0x8562B5045CB25748, 0x0E12909F97BADC66, 0x00006FE5D541F71C };\r\nconst uint64_t p751p1[NWORDS_FIELD]        = { 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0xEEB0000000000000,\r\n                                               0xE3EC968549F878A8, 0xDA959B1A13F7CC76, 0x084E9867D6EBE876, 0x8562B5045CB25748, 0x0E12909F97BADC66, 0x00006FE5D541F71C };\r\nconst uint64_t Montgomery_R2[NWORDS_FIELD] = { 0x233046449DAD4058, 0xDB010161A696452A, 0x5E36941472E3FD8E, 0xF40BFE2082A2E706, 0x4932CCA8904F8751 ,0x1F735F1F1EE7FC81, \r\n                                               0xA24F4D80C1048E18, 0xB56C383CCDB607C5, 0x441DD47B735F9C90, 0x5673ED2C6A6AC82A, 0x06C905261132294B, 0x000041AD830F1F35 }; \r\n\r\n\r\n/*******************************************************/\r\n/************* Field arithmetic functions **************/\r\n\r\n__inline void fpcopy751(felm_t a, felm_t c)\r\n{ // Copy of a field element, c = a\r\n    unsigned int i;\r\n\r\n    for (i = 0; i < NWORDS_FIELD; i++)\r\n        c[i] = a[i];\r\n}\r\n\r\n\r\n__inline void fpzero751(felm_t a)\r\n{ // Zeroing a field element, a = 0\r\n    unsigned int i;\r\n\r\n    for (i = 0; i < NWORDS_FIELD; i++)\r\n        a[i] = 0;\r\n}\r\n\r\n\r\nvoid to_mont(felm_t a, felm_t mc)\r\n{ // Conversion to Montgomery representation\r\n  // mc = a*R^2*R^-1 mod p751 = a*R mod p751, where a in [0, p751-1]\r\n  // The Montgomery constant R^2 mod p751 is the global value \"Montgomery_R2\". \r\n\r\n    fpmul751_mont(a, (digit_t*)&Montgomery_R2, mc);\r\n}\r\n\r\n\r\nvoid from_mont(felm_t ma, felm_t c)\r\n{ // Conversion from Montgomery representation to standard representation\r\n  // c = ma*R^-1 mod p751 = a mod p751, where ma in [0, p751-1].\r\n    digit_t one[NWORDS_FIELD] = {0};\r\n    \r\n    one[0] = 1;\r\n    fpmul751_mont(ma, one, c);\r\n}\r\n\r\n\r\nstatic __inline unsigned int is_felm_zero(felm_t x)\r\n{ // Is x = 0? return 1 (TRUE) if condition is true, 0 (FALSE) otherwise\r\n   // NOTE: this function does not run in constant-time so it can only be used in functions\r\n   //       incorporating countermeasures such as projective randomization.\r\n    unsigned int i;\r\n\r\n    for (i = 0; i < NWORDS_FIELD; i++) {\r\n        if (x[i] != 0) return false;\r\n    }\r\n    return true;\r\n}\r\n\r\n\r\nstatic __inline unsigned int is_felm_even(felm_t x)\r\n{ // Is x even? return 1 (TRUE) if condition is true, 0 (FALSE) otherwise\r\n    return (unsigned int)((x[0] & 1) ^ 1);\r\n}\r\n\r\n\r\nstatic __inline unsigned int is_felm_lt(felm_t x, felm_t y)\r\n{ // Is x < y? return 1 (TRUE) if condition is true, 0 (FALSE) otherwise\r\n  // NOTE: this function does not run in constant-time so it can only be used in functions\r\n  //       incorporating countermeasures such as projective randomization.\r\n    int i;\r\n\r\n    for (i = NWORDS_FIELD-1; i >= 0; i--) {\r\n        if (x[i] < y[i]) { \r\n            return true;\r\n        } else if (x[i] > y[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nvoid copy_words(digit_t* a, digit_t* c, unsigned int nwords)\r\n{ // Copy wordsize digits, c = a, where lng(a) = nwords\r\n    unsigned int i;\r\n        \r\n    for (i = 0; i < nwords; i++) {                      \r\n        c[i] = a[i];\r\n    }\r\n}\r\n\r\n\r\n__inline unsigned int mp_sub(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords)\r\n{ // Multiprecision subtraction, c = a-b, where lng(a) = lng(b) = nwords. Returns the borrow bit \r\n    unsigned int i, borrow = 0;\r\n\r\n    for (i = 0; i < nwords; i++) {\r\n        SUBC(borrow, a[i], b[i], borrow, c[i]);\r\n    }\r\n\r\n    return borrow;\r\n}\r\n\r\n\r\n__inline unsigned int mp_add(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords)\r\n{ // Multiprecision addition, c = a+b, where lng(a) = lng(b) = nwords. Returns the carry bit \r\n    unsigned int i, carry = 0;\r\n        \r\n    for (i = 0; i < nwords; i++) {                      \r\n        ADDC(carry, a[i], b[i], carry, c[i]);\r\n    }\r\n\r\n    return carry;\r\n}\r\n\r\n\r\nvoid mp_shiftr1(digit_t* x, unsigned int nwords)\r\n{ // Multiprecision right shift by one\r\n    unsigned int i;\r\n\r\n    for (i = 0; i < nwords-1; i++) {\r\n        SHIFTR(x[i+1], x[i], 1, x[i], RADIX);\r\n    }\r\n    x[nwords-1] >>= 1;\r\n}\r\n\r\n\r\nvoid mp_shiftl1(digit_t* x, unsigned int nwords)\r\n{ // Multiprecision left right shift by one\r\n    int i;\r\n\r\n    for (i = nwords-1; i > 0; i--) {\r\n        SHIFTL(x[i], x[i-1], 1, x[i], RADIX);\r\n    }\r\n    x[0] <<= 1;\r\n}\r\n\r\n\r\nstatic __inline void power2_setup(felm_t x, int mark)\r\n{  // Set up the value 2^mark\r\n    unsigned int i = 0;\r\n    \r\n    fpzero751(x);\r\n    while (mark >= 0) {\r\n        if (mark < RADIX) {\r\n            x[i] = (digit_t)1 << mark;\r\n        }\r\n        mark -= RADIX;\r\n        i += 1;\r\n    }\r\n}\r\n\r\n\r\nvoid fpmul751_mont(felm_t ma, felm_t mb, felm_t mc)\r\n{ // 751-bit Comba multi-precision multiplication, c = a*b mod p751\r\n    dfelm_t temp = {0};\r\n\r\n    mp_mul(ma, mb, temp, NWORDS_FIELD);\r\n    rdc_mont(temp, mc);\r\n}\r\n\r\n\r\nvoid fpsqr751_mont(felm_t ma, felm_t mc)\r\n{ // 751-bit Comba multi-precision squaring, c = a^2 mod p751\r\n    dfelm_t temp = {0};\r\n\r\n    mp_mul(ma, ma, temp, NWORDS_FIELD);\r\n    rdc_mont(temp, mc);\r\n}\r\n\r\n\r\nvoid fpinv751_mont(felm_t a)\r\n{// Field inversion using Montgomery arithmetic, a = a^-1*R mod p751\r\n    felm_t t[27], tt;\r\n    unsigned int i, j;\r\n    \r\n    // Precomputed table\r\n    fpsqr751_mont(a, tt);\r\n    fpmul751_mont(a, tt, t[0]);\r\n    fpmul751_mont(t[0], tt, t[1]);\r\n    fpmul751_mont(t[1], tt, t[2]);\r\n    fpmul751_mont(t[2], tt, t[3]); \r\n    fpmul751_mont(t[3], tt, t[3]);\r\n    for (i = 3; i <= 8; i++) fpmul751_mont(t[i], tt, t[i+1]);\r\n    fpmul751_mont(t[9], tt, t[9]);\r\n    for (i = 9; i <= 20; i++) fpmul751_mont(t[i], tt, t[i+1]);\r\n    fpmul751_mont(t[21], tt, t[21]); \r\n    for (i = 21; i <= 24; i++) fpmul751_mont(t[i], tt, t[i+1]); \r\n    fpmul751_mont(t[25], tt, t[25]);\r\n    fpmul751_mont(t[25], tt, t[26]);\r\n\r\n    fpcopy751(a, tt);\r\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[20], tt, tt);\r\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[24], tt, tt);\r\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[11], tt, tt);\r\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[8], tt, tt);\r\n    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[2], tt, tt);\r\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[23], tt, tt);\r\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[2], tt, tt);\r\n    for (i = 0; i < 9; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[2], tt, tt);\r\n    for (i = 0; i < 10; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[15], tt, tt);\r\n    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[13], tt, tt);\r\n    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[26], tt, tt);\r\n    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[20], tt, tt);\r\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[11], tt, tt);\r\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[10], tt, tt);\r\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[14], tt, tt);\r\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[4], tt, tt);\r\n    for (i = 0; i < 10; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[18], tt, tt);\r\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[1], tt, tt);\r\n    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[22], tt, tt);\r\n    for (i = 0; i < 10; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[6], tt, tt);\r\n    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[24], tt, tt);\r\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[9], tt, tt);\r\n    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[18], tt, tt);\r\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[17], tt, tt);\r\n    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(a, tt, tt);\r\n    for (i = 0; i < 10; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[16], tt, tt);\r\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[7], tt, tt);\r\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[0], tt, tt);\r\n    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[12], tt, tt);\r\n    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[19], tt, tt);\r\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[22], tt, tt);\r\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[25], tt, tt);\r\n    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[2], tt, tt);\r\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[10], tt, tt);\r\n    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[22], tt, tt);\r\n    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[18], tt, tt);\r\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[4], tt, tt);\r\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[14], tt, tt);\r\n    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[13], tt, tt);\r\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[5], tt, tt);\r\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[23], tt, tt);\r\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[21], tt, tt);\r\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[2], tt, tt);\r\n    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[23], tt, tt);\r\n    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[12], tt, tt);\r\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[9], tt, tt);\r\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[3], tt, tt);\r\n    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[13], tt, tt);\r\n    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[17], tt, tt);\r\n    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[26], tt, tt);\r\n    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[5], tt, tt);\r\n    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[8], tt, tt);\r\n    for (i = 0; i < 8; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[11], tt, tt);\r\n    for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\r\n    fpmul751_mont(t[22], tt, tt);\r\n    for (i = 0; i < 7; i++) fpsqr751_mont(tt, tt);\r\n    for (j = 0; j < 61; j++) {\r\n        fpmul751_mont(t[26], tt, tt);\r\n        for (i = 0; i < 6; i++) fpsqr751_mont(tt, tt);\r\n    }\r\n    fpmul751_mont(t[25], tt, a);  \r\n}\r\n\r\n\r\n/***********************************************/\r\n/************* GF(p^2) FUNCTIONS ***************/\r\n\r\nvoid fp2copy751(f2elm_t a, f2elm_t c)\r\n{// Copy of a GF(p751^2) element, c = a\r\n    fpcopy751(a[0], c[0]);\r\n    fpcopy751(a[1], c[1]);\r\n}\r\n\r\n\r\nvoid fp2zero751(f2elm_t a)\r\n{// Zeroing a GF(p751^2) element, a = 0\r\n    fpzero751(a[0]);\r\n    fpzero751(a[1]);\r\n}\r\n\r\n\r\nvoid fp2neg751(f2elm_t a)\r\n{// GF(p751^2) negation, a = -a in GF(p751^2)\r\n    fpneg751(a[0]);\r\n    fpneg751(a[1]);\r\n}\r\n\r\n\r\n__inline void fp2add751(f2elm_t a, f2elm_t b, f2elm_t c)           \r\n{// GF(p751^2) addition, c = a+b in GF(p751^2)\r\n    fpadd751(a[0], b[0], c[0]);\r\n    fpadd751(a[1], b[1], c[1]);\r\n}\r\n\r\n\r\n__inline void fp2sub751(f2elm_t a, f2elm_t b, f2elm_t c)          \r\n{// GF(p751^2) subtraction, c = a-b in GF(p751^2) \r\n    fpsub751(a[0], b[0], c[0]);\r\n    fpsub751(a[1], b[1], c[1]);\r\n}\r\n\r\n\r\nvoid fp2div2_751(f2elm_t a, f2elm_t c)          \r\n{// GF(p751^2) division by two, c = a/2  in GF(p751^2) \r\n    fpdiv2_751(a[0], c[0]);\r\n    fpdiv2_751(a[1], c[1]);\r\n}\r\n\r\n\r\nvoid fp2sqr751_mont(f2elm_t a, f2elm_t c)\r\n{// GF(p751^2) squaring using Montgomery arithmetic, c = a^2 in GF(p751^2)\r\n    felm_t t1, t2, t3;\r\n\r\n    mp_add(a[0], a[1], t1, NWORDS_FIELD);    // t1 = a0+a1 \r\n    fpsub751(a[0], a[1], t2);                // t2 = a0-a1\r\n    mp_add(a[0], a[0], t3, NWORDS_FIELD);    // t3 = 2a0\r\n    fpmul751_mont(t1, t2, c[0]);             // c0 = (a0+a1)(a0-a1)\r\n    fpmul751_mont(t3, a[1], c[1]);           // c1 = 2a0*a1\r\n}\r\n\r\n\r\nvoid fp2mul751_mont(f2elm_t a, f2elm_t b, f2elm_t c)\r\n{// GF(p751^2) multiplication using Montgomery arithmetic, c = a*b in GF(p751^2)\r\n    felm_t t1, t2;\r\n    dfelm_t tt1, tt2, tt3; \r\n    digit_t mask;\r\n    unsigned int i, borrow;\r\n\r\n    mp_mul(a[0], b[0], tt1, NWORDS_FIELD);           // tt1 = a0*b0\r\n    mp_mul(a[1], b[1], tt2, NWORDS_FIELD);           // tt2 = a1*b1\r\n    mp_add(a[0], a[1], t1, NWORDS_FIELD);            // t1 = a0+a1\r\n    mp_add(b[0], b[1], t2, NWORDS_FIELD);            // t2 = b0+b1\r\n    borrow = mp_sub(tt1, tt2, tt3, 2*NWORDS_FIELD);  // tt3 = a0*b0 - a1*b1\r\n    mask = 0 - (digit_t)borrow;                      // if tt3 < 0 then mask = 0xFF..F, else if tt3 >= 0 then mask = 0x00..0\r\n    borrow = 0;\r\n    for (i = 0; i < NWORDS_FIELD; i++) {             // tt3 = tt3 + (mask & 2^768*p751)\r\n        ADDC(borrow, tt3[NWORDS_FIELD+i], ((digit_t*)p751)[i] & mask, borrow, tt3[NWORDS_FIELD+i]);\r\n    }\r\n    rdc_mont(tt3, c[0]);                             // c[0] = a0*b0 - a1*b1\r\n    mp_add(tt1, tt2, tt1, 2*NWORDS_FIELD);           // tt1 = a0*b0 + a1*b1\r\n    mp_mul(t1, t2, tt2, NWORDS_FIELD);               // tt2 = (a0+a1)*(b0+b1)\r\n    mp_sub(tt2, tt1, tt2, 2*NWORDS_FIELD);           // tt2 = (a0+a1)*(b0+b1) - a0*b0 - a1*b1 \r\n    rdc_mont(tt2, c[1]);                             // c[1] = (a0+a1)*(b0+b1) - a0*b0 - a1*b1 \r\n}\r\n\r\n\r\nvoid to_fp2mont(f2elm_t a, f2elm_t mc)\r\n{ // Conversion of a GF(p751^2) element to Montgomery representation\r\n  // mc_i = a_i*R^2*R^-1 = a_i*R in GF(p751^2). \r\n\r\n    to_mont(a[0], mc[0]);\r\n    to_mont(a[1], mc[1]);\r\n}\r\n\r\n\r\nvoid from_fp2mont(f2elm_t ma, f2elm_t c)\r\n{ // Conversion of a GF(p751^2) element from Montgomery representation to standard representation\r\n  // c_i = ma_i*R^-1 = a_i in GF(p751^2).\r\n\r\n    from_mont(ma[0], c[0]);\r\n    from_mont(ma[1], c[1]);\r\n}\r\n\r\n\r\nvoid fp2inv751_mont(f2elm_t a)\r\n{// GF(p751^2) inversion using Montgomery arithmetic, a = (a0-i*a1)/(a0^2+a1^2)\r\n    f2elm_t t1;\r\n\r\n    fpsqr751_mont(a[0], t1[0]);             // t10 = a0^2\r\n    fpsqr751_mont(a[1], t1[1]);             // t11 = a1^2\r\n    fpadd751(t1[0], t1[1], t1[0]);          // t10 = a0^2+a1^2\r\n    fpinv751_mont(t1[0]);                   // t10 = (a0^2+a1^2)^-1\r\n    fpneg751(a[1]);                         // a = a0-i*a1\r\n    fpmul751_mont(a[0], t1[0], a[0]);\r\n    fpmul751_mont(a[1], t1[0], a[1]);       // a = (a0-i*a1)*(a0^2+a1^2)^-1\r\n}\r\n\r\n\r\nvoid swap_points_basefield(point_basefield_proj_t P, point_basefield_proj_t Q, digit_t option)\r\n{ // Swap points over the base field \r\n  // If option = 0 then P <- P and Q <- Q, else if option = 0xFF...FF then P <- Q and Q <- P\r\n    digit_t temp;\r\n    unsigned int i;\r\n\r\n    for (i = 0; i < NWORDS_FIELD; i++) {\r\n        temp = option & (P->X[i] ^ Q->X[i]);\r\n        P->X[i] = temp ^ P->X[i]; \r\n        Q->X[i] = temp ^ Q->X[i]; \r\n        temp = option & (P->Z[i] ^ Q->Z[i]);\r\n        P->Z[i] = temp ^ P->Z[i]; \r\n        Q->Z[i] = temp ^ Q->Z[i]; \r\n    }\r\n}\r\n\r\n\r\nvoid swap_points(point_proj_t P, point_proj_t Q, digit_t option)\r\n{ // Swap points\r\n  // If option = 0 then P <- P and Q <- Q, else if option = 0xFF...FF then P <- Q and Q <- P\r\n    digit_t temp;\r\n    unsigned int i;\r\n\r\n    for (i = 0; i < NWORDS_FIELD; i++) {\r\n        temp = option & (P->X[0][i] ^ Q->X[0][i]);\r\n        P->X[0][i] = temp ^ P->X[0][i]; \r\n        Q->X[0][i] = temp ^ Q->X[0][i]; \r\n        temp = option & (P->Z[0][i] ^ Q->Z[0][i]);\r\n        P->Z[0][i] = temp ^ P->Z[0][i]; \r\n        Q->Z[0][i] = temp ^ Q->Z[0][i]; \r\n        temp = option & (P->X[1][i] ^ Q->X[1][i]);\r\n        P->X[1][i] = temp ^ P->X[1][i]; \r\n        Q->X[1][i] = temp ^ Q->X[1][i]; \r\n        temp = option & (P->Z[1][i] ^ Q->Z[1][i]);\r\n        P->Z[1][i] = temp ^ P->Z[1][i]; \r\n        Q->Z[1][i] = temp ^ Q->Z[1][i]; \r\n    }\r\n}\r\n\r\n\r\nvoid select_f2elm(f2elm_t x, f2elm_t y, f2elm_t z, digit_t option)\r\n{ // Select either x or y depending on value of option \r\n  // If option = 0 then z <- x, else if option = 0xFF...FF then z <- y\r\n    unsigned int i;\r\n\r\n    for (i = 0; i < NWORDS_FIELD; i++) {\r\n        z[0][i] = (option & (x[0][i] ^ y[0][i])) ^ x[0][i]; \r\n        z[1][i] = (option & (x[1][i] ^ y[1][i])) ^ x[1][i]; \r\n    }\r\n}","/********************************************************************************************\r\n* SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key \r\n*       exchange providing 128 bits of quantum security and 192 bits of classical security.\r\n*\r\n*    Copyright (c) Microsoft Corporation. All rights reserved.\r\n*\r\n*\r\n* Abstract: internal header file\r\n*\r\n*********************************************************************************************/  \r\n\r\n#ifndef __SIDH_INTERNAL_H__\r\n#define __SIDH_INTERNAL_H__\r\n\r\n\r\n// For C++\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n\r\n#include \"SIDH.h\"   \r\n    \r\n\r\n// Basic constants\r\n\r\n#define ALICE                 0\r\n#define BOB                   1 \r\n#define MAX_INT_POINTS_ALICE  8      \r\n// Fixed parameters for isogeny tree computation    \r\n#define MAX_INT_POINTS_BOB    10 \r\n#define MAX_Alice             185   \r\n#define MAX_Bob               239\r\n   \r\n\r\n// SIDH's basic element definitions and point representations\r\n\r\ntypedef digit_t felm_t[NWORDS_FIELD];                             // Datatype for representing 751-bit field elements (768-bit max.)\r\ntypedef digit_t dfelm_t[2*NWORDS_FIELD];                          // Datatype for representing double-precision 2x751-bit field elements (2x768-bit max.) \r\ntypedef felm_t  f2elm_t[2];                                       // Datatype for representing quadratic extension field elements GF(p751^2)\r\ntypedef f2elm_t publickey_t[4];                                   // Datatype for representing public keys equivalent to four GF(p751^2) elements\r\n        \r\ntypedef struct { f2elm_t x; f2elm_t y; } point_affine;            // Point representation in affine coordinates on Montgomery curve.\r\ntypedef point_affine point_t[1]; \r\n        \r\ntypedef struct { f2elm_t X; f2elm_t Z; } point_proj;              // Point representation in projective XZ Montgomery coordinates.\r\ntypedef point_proj point_proj_t[1]; \r\n        \r\ntypedef struct { felm_t x; felm_t y; } point_basefield_affine;    // Point representation in affine coordinates on Montgomery curve over the base field.\r\ntypedef point_basefield_affine point_basefield_t[1];  \r\n        \r\ntypedef struct { felm_t X; felm_t Z; } point_basefield_proj;      // Point representation in projective XZ Montgomery coordinates over the base field.\r\ntypedef point_basefield_proj point_basefield_proj_t[1]; \r\n    \r\n\r\n// Macro definitions\r\n\r\n#define NBITS_TO_NBYTES(nbits)      (((nbits)+7)/8)                                          // Conversion macro from number of bits to number of bytes\r\n#define NBITS_TO_NWORDS(nbits)      (((nbits)+(sizeof(digit_t)*8)-1)/(sizeof(digit_t)*8))    // Conversion macro from number of bits to number of computer words\r\n#define NBYTES_TO_NWORDS(nbytes)    (((nbytes)+sizeof(digit_t)-1)/sizeof(digit_t))           // Conversion macro from number of bytes to number of computer words\r\n\r\n// Macro to avoid compiler warnings when detecting unreferenced parameters\r\n#define UNREFERENCED_PARAMETER(PAR) (PAR)\r\n\r\n\r\n/********************** Constant-time unsigned comparisons ***********************/\r\n\r\n// The following functions return 1 (TRUE) if condition is true, 0 (FALSE) otherwise\r\n\r\nstatic __inline unsigned int is_digit_nonzero_ct(digit_t x)\r\n{ // Is x != 0?\r\n    return (unsigned int)((x | (0-x)) >> (RADIX-1));\r\n}\r\n\r\nstatic __inline unsigned int is_digit_zero_ct(digit_t x)\r\n{ // Is x = 0?\r\n    return (unsigned int)(1 ^ is_digit_nonzero_ct(x));\r\n}\r\n\r\nstatic __inline unsigned int is_digit_lessthan_ct(digit_t x, digit_t y)\r\n{ // Is x < y?\r\n    return (unsigned int)((x ^ ((x ^ y) | ((x - y) ^ y))) >> (RADIX-1)); \r\n}\r\n\r\n\r\n/********************** Macros for platform-dependent operations **********************/\r\n\r\n#if defined(GENERIC_IMPLEMENTATION)\r\n\r\n// Digit multiplication\r\n#define MUL(multiplier, multiplicand, hi, lo)                                                     \\\r\n    digit_x_digit((multiplier), (multiplicand), &(lo));\r\n    \r\n// Digit addition with carry\r\n#define ADDC(carryIn, addend1, addend2, carryOut, sumOut)                                         \\\r\n    { digit_t tempReg = (addend1) + (digit_t)(carryIn);                                           \\\r\n    (sumOut) = (addend2) + tempReg;                                                               \\\r\n    (carryOut) = (is_digit_lessthan_ct(tempReg, (digit_t)(carryIn)) | is_digit_lessthan_ct((sumOut), tempReg)); }\r\n\r\n// Digit subtraction with borrow\r\n#define SUBC(borrowIn, minuend, subtrahend, borrowOut, differenceOut)                             \\\r\n    { digit_t tempReg = (minuend) - (subtrahend);                                                 \\\r\n    unsigned int borrowReg = (is_digit_lessthan_ct((minuend), (subtrahend)) | ((borrowIn) & is_digit_zero_ct(tempReg)));  \\\r\n    (differenceOut) = tempReg - (digit_t)(borrowIn);                                              \\\r\n    (borrowOut) = borrowReg; }\r\n    \r\n// Shift right with flexible datatype\r\n#define SHIFTR(highIn, lowIn, shift, shiftOut, DigitSize)                                         \\\r\n    (shiftOut) = ((lowIn) >> (shift)) ^ ((highIn) << (DigitSize - (shift)));\r\n    \r\n// Shift left with flexible datatype\r\n#define SHIFTL(highIn, lowIn, shift, shiftOut, DigitSize)                                         \\\r\n    (shiftOut) = ((highIn) << (shift)) ^ ((lowIn) >> (DigitSize - (shift)));\r\n\r\n// 64x64-bit multiplication\r\n#define MUL128(multiplier, multiplicand, product)                                                 \\\r\n    mp_mul((digit_t*)&(multiplier), (digit_t*)&(multiplicand), (digit_t*)&(product), NWORDS_FIELD/2);\r\n\r\n// 128-bit addition, inputs < 2^127\r\n#define ADD128(addend1, addend2, addition)                                                        \\\r\n    mp_add((digit_t*)(addend1), (digit_t*)(addend2), (digit_t*)(addition), NWORDS_FIELD);\r\n\r\n// 128-bit addition with output carry\r\n#define ADC128(addend1, addend2, carry, addition)                                                 \\\r\n    (carry) = mp_add((digit_t*)(addend1), (digit_t*)(addend2), (digit_t*)(addition), NWORDS_FIELD);\r\n\r\n#elif (TARGET == TARGET_AMD64 && OS_TARGET == OS_WIN)\r\n\r\n// Digit multiplication\r\n#define MUL(multiplier, multiplicand, hi, lo)                                                     \\\r\n    (lo) = _umul128((multiplier), (multiplicand), (hi));                \r\n\r\n// Digit addition with carry\r\n#define ADDC(carryIn, addend1, addend2, carryOut, sumOut)                                         \\\r\n    (carryOut) = _addcarry_u64((carryIn), (addend1), (addend2), &(sumOut));\r\n\r\n// Digit subtraction with borrow\r\n#define SUBC(borrowIn, minuend, subtrahend, borrowOut, differenceOut)                             \\\r\n    (borrowOut) = _subborrow_u64((borrowIn), (minuend), (subtrahend), &(differenceOut));\r\n\r\n// Digit shift right\r\n#define SHIFTR(highIn, lowIn, shift, shiftOut, DigitSize)                                         \\\r\n    (shiftOut) = __shiftright128((lowIn), (highIn), (shift));\r\n\r\n// Digit shift left\r\n#define SHIFTL(highIn, lowIn, shift, shiftOut, DigitSize)                                         \\\r\n    (shiftOut) = __shiftleft128((lowIn), (highIn), (shift));\r\n\r\n// 64x64-bit multiplication\r\n#define MUL128(multiplier, multiplicand, product)                                                 \\\r\n    (product)[0] = _umul128((multiplier), (multiplicand), &(product)[1]);\r\n\r\n// 128-bit addition, inputs < 2^127\r\n#define ADD128(addend1, addend2, addition)                                                        \\\r\n    { unsigned char carry = _addcarry_u64(0, (addend1)[0], (addend2)[0], &(addition)[0]);         \\\r\n    _addcarry_u64(carry, (addend1)[1], (addend2)[1], &(addition)[1]); }\r\n\r\n// 128-bit addition with output carry\r\n#define ADC128(addend1, addend2, carry, addition)                                                 \\\r\n    (carry) = _addcarry_u64(0, (addend1)[0], (addend2)[0], &(addition)[0]);                       \\\r\n    (carry) = _addcarry_u64((carry), (addend1)[1], (addend2)[1], &(addition)[1]); \r\n\r\n// 128-bit subtraction, subtrahend < 2^127\r\n#define SUB128(minuend, subtrahend, difference)                                                   \\\r\n    { unsigned char borrow = _subborrow_u64(0, (minuend)[0], (subtrahend)[0], &(difference)[0]);  \\\r\n    _subborrow_u64(borrow, (minuend)[1], (subtrahend)[1], &(difference)[1]); }\r\n\r\n// 128-bit right shift, max. shift value is 64\r\n#define SHIFTR128(Input, shift, shiftOut)                                                         \\\r\n    (shiftOut)[0]  = __shiftright128((Input)[0], (Input)[1], (shift));                            \\\r\n    (shiftOut)[1] = (Input)[1] >> (shift);    \r\n\r\n// 128-bit left shift, max. shift value is 64\r\n#define SHIFTL128(Input, shift, shiftOut)                                                         \\\r\n    (shiftOut)[1]  = __shiftleft128((Input)[0], (Input)[1], (shift));                             \\\r\n    (shiftOut)[0] = (Input)[0] << (shift);  \r\n\r\n#define MULADD128(multiplier, multiplicand, addend, carry, result);    \\\r\n    { uint128_t product;                                               \\\r\n      MUL128(multiplier, multiplicand, product);                       \\\r\n      ADC128(addend, product, carry, result); }   \r\n\r\n#elif (TARGET == TARGET_AMD64 && OS_TARGET == OS_LINUX)\r\n\r\n// Digit multiplication\r\n#define MUL(multiplier, multiplicand, hi, lo)                                                     \\\r\n    { uint128_t tempReg = (uint128_t)(multiplier) * (uint128_t)(multiplicand);                    \\\r\n    *(hi) = (digit_t)(tempReg >> RADIX);                                                          \\\r\n    (lo) = (digit_t)tempReg; }\r\n\r\n// Digit addition with carry\r\n#define ADDC(carryIn, addend1, addend2, carryOut, sumOut)                                         \\\r\n    { uint128_t tempReg = (uint128_t)(addend1) + (uint128_t)(addend2) + (uint128_t)(carryIn);     \\\r\n    (carryOut) = (digit_t)(tempReg >> RADIX);                                                     \\\r\n    (sumOut) = (digit_t)tempReg; }  \r\n    \r\n// Digit subtraction with borrow\r\n#define SUBC(borrowIn, minuend, subtrahend, borrowOut, differenceOut)                             \\\r\n    { uint128_t tempReg = (uint128_t)(minuend) - (uint128_t)(subtrahend) - (uint128_t)(borrowIn); \\\r\n    (borrowOut) = (digit_t)(tempReg >> (sizeof(uint128_t)*8 - 1));                                \\\r\n    (differenceOut) = (digit_t)tempReg; }\r\n\r\n// Digit shift right\r\n#define SHIFTR(highIn, lowIn, shift, shiftOut, DigitSize)                                         \\\r\n    (shiftOut) = ((lowIn) >> (shift)) ^ ((highIn) << (RADIX - (shift)));\r\n\r\n// Digit shift left\r\n#define SHIFTL(highIn, lowIn, shift, shiftOut, DigitSize)                                         \\\r\n    (shiftOut) = ((highIn) << (shift)) ^ ((lowIn) >> (RADIX - (shift)));\r\n\r\n#endif\r\n\r\n\r\n// Multiprecision multiplication selection\r\n#if (TARGET == TARGET_AMD64)\r\n    #define mp_mul_comba         mp_mul\r\n#else\r\n    #define mp_mul_schoolbook    mp_mul\r\n#endif\r\n\r\n\r\n\r\n/**************** Function prototypes ****************/\r\n/************* Multiprecision functions **************/ \r\n\r\n// Copy wordsize digits, c = a, where lng(a) = nwords\r\nvoid copy_words(digit_t* a, digit_t* c, unsigned int nwords);\r\n\r\n// Multiprecision addition, c = a+b, where lng(a) = lng(b) = nwords. Returns the carry bit \r\nextern unsigned int mp_add(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords);\r\n\r\n// Multiprecision subtraction, c = a-b, where lng(a) = lng(b) = nwords. Returns the borrow bit \r\nextern unsigned int mp_sub(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords);\r\n\r\n// Multiprecision right shift by one\r\nvoid mp_shiftr1(digit_t* x, unsigned int nwords);\r\n\r\n// Multiprecision left right shift by one    \r\nvoid mp_shiftl1(digit_t* x, unsigned int nwords);\r\n\r\n// Digit multiplication, digit * digit -> 2-digit result\r\nvoid digit_x_digit(digit_t a, digit_t b, digit_t* c);    \r\n\r\n// Multiprecision schoolbook multiply, c = a*b, where lng(a) = lng(b) = nwords.\r\nvoid mp_mul_schoolbook(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords);\r\n\r\n// Multiprecision comba multiply, c = a*b, where lng(a) = lng(b) = nwords.\r\nvoid mp_mul_comba(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords);\r\n\r\n/************ Field arithmetic functions *************/\r\n\r\n// Copy of a field element, c = a\r\nvoid fpcopy751(felm_t a, felm_t c);\r\n\r\n// Zeroing a field element, a = 0\r\nvoid fpzero751(felm_t a);\r\n\r\n// Modular addition, c = a+b mod p751\r\nextern void fpadd751(digit_t* a, digit_t* b, digit_t* c);\r\nextern void fpadd751_asm(digit_t* a, digit_t* b, digit_t* c);\r\n\r\n// Modular subtraction, c = a-b mod p751\r\nextern void fpsub751(digit_t* a, digit_t* b, digit_t* c);\r\nextern void fpsub751_asm(digit_t* a, digit_t* b, digit_t* c);\r\n\r\n// Modular negation, a = -a mod p751        \r\nextern void fpneg751(digit_t* a);  \r\n\r\n// Modular division by two, c = a/2 mod p751.\r\nvoid fpdiv2_751(digit_t* a, digit_t* c);\r\n\r\n// 751-bit Montgomery reduction, c = a mod p\r\nvoid rdc_mont(digit_t* a, digit_t* c);\r\n            \r\n// Field multiplication using Montgomery arithmetic, c = a*b*R^-1 mod p751, where R=2^768\r\nvoid fpmul751_mont(felm_t a, felm_t b, felm_t c);\r\nvoid mul751_asm(felm_t a, felm_t b, dfelm_t c);\r\nvoid rdc751_asm(dfelm_t ma, dfelm_t mc);\r\n   \r\n// Field squaring using Montgomery arithmetic, c = a*b*R^-1 mod p751, where R=2^768\r\nvoid fpsqr751_mont(felm_t ma, felm_t mc);\r\n\r\n// Conversion to Montgomery representation\r\nvoid to_mont(felm_t a, felm_t mc);\r\n    \r\n// Conversion from Montgomery representation to standard representation\r\nvoid from_mont(felm_t ma, felm_t c);\r\n\r\n// Field inversion, a = a^-1 in GF(p751)\r\nvoid fpinv751_mont(felm_t a);\r\n\r\n/************ GF(p^2) arithmetic functions *************/\r\n    \r\n// Copy of a GF(p751^2) element, c = a\r\nvoid fp2copy751(f2elm_t a, f2elm_t c);\r\n\r\n// Zeroing a GF(p751^2) element, a = 0\r\nvoid fp2zero751(f2elm_t a);\r\n\r\n// GF(p751^2) negation, a = -a in GF(p751^2)\r\nvoid fp2neg751(f2elm_t a);\r\n\r\n// GF(p751^2) addition, c = a+b in GF(p751^2)\r\nextern void fp2add751(f2elm_t a, f2elm_t b, f2elm_t c);           \r\n\r\n// GF(p751^2) subtraction, c = a-b in GF(p751^2)\r\nextern void fp2sub751(f2elm_t a, f2elm_t b, f2elm_t c); \r\n\r\n// GF(p751^2) division by two, c = a/2  in GF(p751^2) \r\nvoid fp2div2_751(f2elm_t a, f2elm_t c);\r\n            \r\n// GF(p751^2) squaring using Montgomery arithmetic, c = a^2 in GF(p751^2)\r\nvoid fp2sqr751_mont(f2elm_t a, f2elm_t c);\r\n \r\n// GF(p751^2) multiplication using Montgomery arithmetic, c = a*b in GF(p751^2)\r\nvoid fp2mul751_mont(f2elm_t a, f2elm_t b, f2elm_t c);\r\n    \r\n// Conversion of a GF(p751^2) element to Montgomery representation\r\nvoid to_fp2mont(f2elm_t a, f2elm_t mc);\r\n\r\n// Conversion of a GF(p751^2) element from Montgomery representation to standard representation\r\nvoid from_fp2mont(f2elm_t ma, f2elm_t c);\r\n\r\n// GF(p751^2) inversion using Montgomery arithmetic, a = (a0-i*a1)/(a0^2+a1^2)\r\nvoid fp2inv751_mont(f2elm_t a);\r\n\r\n// Select either x or y depending on value of option \r\nvoid select_f2elm(f2elm_t x, f2elm_t y, f2elm_t z, digit_t option);\r\n\r\n/************ Elliptic curve and isogeny functions *************/\r\n\r\n// Check if curve isogeny structure is NULL\r\nbool is_CurveIsogenyStruct_null(PCurveIsogenyStruct pCurveIsogeny);\r\n\r\n// Swap points over the base field \r\nvoid swap_points_basefield(point_basefield_proj_t P, point_basefield_proj_t Q, digit_t option);\r\n\r\n// Swap points\r\nvoid swap_points(point_proj_t P, point_proj_t Q, digit_t option);\r\n\r\n// Computes the j-invariant of a Montgomery curve with projective constant.\r\nvoid j_inv(f2elm_t A, f2elm_t C, f2elm_t jinv);\r\n\r\n// Simultaneous doubling and differential addition.\r\nvoid xDBLADD(point_proj_t P, point_proj_t Q, f2elm_t xPQ, f2elm_t A24);\r\n\r\n// Doubling of a Montgomery point in projective coordinates (X:Z).\r\nvoid xDBL(point_proj_t P, point_proj_t Q, f2elm_t A24, f2elm_t C24);\r\n\r\n// Computes [2^e](X:Z) on Montgomery curve with projective constant via e repeated doublings.\r\nvoid xDBLe(point_proj_t P, point_proj_t Q, f2elm_t A, f2elm_t C, int e);\r\n\r\n// Computes [2^e](X:Z) on Montgomery curve with projective constant via e repeated doublings and collects a few intermediate multiples.\r\nvoid xDBLe_collect(point_proj_t P, point_proj_t Q, f2elm_t A, f2elm_t C, unsigned int left_bound, const unsigned int right_bound, const unsigned int* col, point_proj_t* pts, unsigned int* pts_index, unsigned int *npts);\r\n\r\n// Differential addition.\r\nvoid xADD(point_proj_t P, point_proj_t Q, f2elm_t xPQ);\r\n\r\n// Doubling of a Montgomery point in projective coordinates (X:Z) over the base field.\r\nvoid xDBL_basefield(point_basefield_proj_t P, point_basefield_proj_t Q);\r\n\r\n// Simultaneous doubling and differential addition over the base field.\r\nvoid xDBLADD_basefield(point_basefield_proj_t P, point_basefield_proj_t Q, felm_t xPQ, felm_t A24);\r\n\r\n// The Montgomery ladder\r\nvoid ladder(felm_t x, digit_t* m, point_basefield_proj_t P, point_basefield_proj_t Q, felm_t A24, unsigned int order_bits, unsigned int order_fullbits, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// Computes key generation entirely in the base field\r\nCRYPTO_STATUS secret_pt(point_basefield_t P, digit_t* m, unsigned int AliceOrBob, point_proj_t R, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// Computes P+[m]Q via x-only arithmetic.\r\nCRYPTO_STATUS ladder_3_pt(f2elm_t xP, f2elm_t xQ, f2elm_t xPQ, digit_t* m, unsigned int AliceOrBob, point_proj_t W, f2elm_t A, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// Computes the corresponding 4-isogeny of a projective Montgomery point (X4:Z4) of order 4.\r\nvoid get_4_isog(point_proj_t P, f2elm_t A, f2elm_t C, f2elm_t* coeff);\r\n\r\n// Evaluates the isogeny at the point (X:Z) in the domain of the isogeny\r\nvoid eval_4_isog(point_proj_t P, f2elm_t* coeff);\r\n\r\n// Computes first 4-isogeny computed by Alice.\r\nvoid first_4_isog(point_proj_t P, f2elm_t A, f2elm_t Aout, f2elm_t Cout, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// Tripling of a Montgomery point in projective coordinates (X:Z).\r\nvoid xTPL(point_proj_t P, point_proj_t Q, f2elm_t A, f2elm_t C);\r\n\r\n// Computes [3^e](X:Z) on Montgomery curve with projective constant via e repeated triplings.\r\nvoid xTPLe(point_proj_t P, point_proj_t Q, f2elm_t A, f2elm_t C, int e);\r\n\r\n// Computes [3^e](X:Z) on Montgomery curve with projective constant via e repeated triplings and collects a few intermediate multiples.    \r\nvoid xTPLe_collect(point_proj_t P, point_proj_t Q, f2elm_t A, f2elm_t C, unsigned int left_bound, const unsigned int right_bound, const unsigned int* col, point_proj_t* pts, unsigned int* pts_index, unsigned int *npts);\r\n\r\n// Computes the corresponding 3-isogeny of a projective Montgomery point (X3:Z3) of order 3.\r\nvoid get_3_isog(point_proj_t P, f2elm_t A, f2elm_t C);\r\n\r\n// Computes the 3-isogeny R=phi(X:Z), given projective point (X3:Z3) of order 3 on a Montgomery curve and a point P = (X:Z).\r\nvoid eval_3_isog(point_proj_t P, point_proj_t Q);\r\n\r\n// 4-way simultaneous inversion\r\nvoid inv_4_way(f2elm_t z1, f2elm_t z2, f2elm_t z3, f2elm_t z4);\r\n\r\n// Computing the point D = (x(Q-P),z(Q-P))\r\nvoid distort_and_diff(felm_t xP, point_proj_t d, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n\r\n#endif\r\n","/********************************************************************************************\r\n* SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key \r\n*       exchange providing 128 bits of quantum security and 192 bits of classical security.\r\n*\r\n*    Copyright (c) Microsoft Corporation. All rights reserved.\r\n*\r\n*\r\n* Abstract: portable modular arithmetic\r\n*\r\n*********************************************************************************************/\r\n\r\n#include \"../SIDH_internal.h\"\r\n\r\n\r\n// Global constants\r\nextern const uint64_t p751[NWORDS_FIELD];\r\nextern const uint64_t p751p1[NWORDS_FIELD]; \r\n\r\n\r\n__inline void fpadd751(digit_t* a, digit_t* b, digit_t* c)\r\n{ // Modular addition, c = a+b mod p751.\r\n  // Inputs: a, b in [0, p751-1] \r\n  // Output: c in [0, p751-1] \r\n    unsigned int i, carry = 0;\r\n    digit_t mask;\r\n\r\n    for (i = 0; i < NWORDS_FIELD; i++) {\r\n        ADDC(carry, a[i], b[i], carry, c[i]); \r\n    }\r\n\r\n    carry = 0;\r\n    for (i = 0; i < NWORDS_FIELD; i++) {\r\n        SUBC(carry, c[i], ((digit_t*)p751)[i], carry, c[i]); \r\n    }\r\n    mask = 0 - (digit_t)carry;\r\n\r\n    carry = 0;\r\n    for (i = 0; i < NWORDS_FIELD; i++) {\r\n        ADDC(carry, c[i], ((digit_t*)p751)[i] & mask, carry, c[i]); \r\n    }\r\n} \r\n\r\n\r\n__inline void fpsub751(digit_t* a, digit_t* b, digit_t* c)\r\n{ // Modular subtraction, c = a-b mod p751.\r\n  // Inputs: a, b in [0, p751-1] \r\n  // Output: c in [0, p751-1] \r\n    unsigned int i, borrow = 0;\r\n    digit_t mask;\r\n\r\n    for (i = 0; i < NWORDS_FIELD; i++) {\r\n        SUBC(borrow, a[i], b[i], borrow, c[i]); \r\n    }\r\n    mask = 0 - (digit_t)borrow;\r\n\r\n    borrow = 0;\r\n    for (i = 0; i < NWORDS_FIELD; i++) {\r\n        ADDC(borrow, c[i], ((digit_t*)p751)[i] & mask, borrow, c[i]); \r\n    }\r\n}\r\n\r\n\r\n__inline void fpneg751(digit_t* a)\r\n{ // Modular negation, a = -a mod p751.\r\n  // Input/output: a in [0, p751-1] \r\n    unsigned int i, borrow = 0;\r\n\r\n    for (i = 0; i < NWORDS_FIELD; i++) {\r\n        SUBC(borrow, ((digit_t*)p751)[i], a[i], borrow, a[i]); \r\n    }\r\n}\r\n\r\n\r\nvoid fpdiv2_751(digit_t* a, digit_t* c)\r\n{ // Modular division by two, c = a/2 mod p751.\r\n  // Input : a in [0, p751-1] \r\n  // Output: c in [0, p751-1] \r\n    unsigned int i, carry = 0;\r\n    digit_t mask;\r\n        \r\n    mask = 0 - (digit_t)(a[0] & 1);    // If a is odd compute a+p521\r\n    for (i = 0; i < NWORDS_FIELD; i++) {\r\n        ADDC(carry, a[i], ((digit_t*)p751)[i] & mask, carry, c[i]); \r\n    }\r\n\r\n    mp_shiftr1(c, NWORDS_FIELD);\r\n} \r\n\r\n\r\nvoid digit_x_digit(digit_t a, digit_t b, digit_t* c)\r\n{ // Digit multiplication, digit * digit -> 2-digit result    \r\n    register digit_t al, ah, bl, bh, temp;\r\n    digit_t albl, albh, ahbl, ahbh, res1, res2, res3, carry;\r\n    digit_t mask_low = (digit_t)(-1) >> (sizeof(digit_t)*4), mask_high = (digit_t)(-1) << (sizeof(digit_t)*4);\r\n\r\n    al = a & mask_low;                        // Low part\r\n    ah = a >> (sizeof(digit_t) * 4);          // High part\r\n    bl = b & mask_low;\r\n    bh = b >> (sizeof(digit_t) * 4);\r\n\r\n    albl = al*bl;\r\n    albh = al*bh;\r\n    ahbl = ah*bl;\r\n    ahbh = ah*bh;\r\n    c[0] = albl & mask_low;                   // C00\r\n\r\n    res1 = albl >> (sizeof(digit_t) * 4);\r\n    res2 = ahbl & mask_low;\r\n    res3 = albh & mask_low;  \r\n    temp = res1 + res2 + res3;\r\n    carry = temp >> (sizeof(digit_t) * 4);\r\n    c[0] ^= temp << (sizeof(digit_t) * 4);    // C01   \r\n\r\n    res1 = ahbl >> (sizeof(digit_t) * 4);\r\n    res2 = albh >> (sizeof(digit_t) * 4);\r\n    res3 = ahbh & mask_low;\r\n    temp = res1 + res2 + res3 + carry;\r\n    c[1] = temp & mask_low;                   // C10 \r\n    carry = temp & mask_high; \r\n    c[1] ^= (ahbh & mask_high) + carry;       // C11\r\n}\r\n\r\n//static __inline \r\nvoid mp_mul_schoolbook(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords)\r\n{ // Multiprecision schoolbook multiply, c = a*b, where lng(a) = lng(b) = nwords.   \r\n    unsigned int i, j;\r\n    digit_t u, v, UV[2];\r\n    unsigned int carry = 0;\r\n\r\n     for (i = 0; i < (2*nwords); i++) c[i] = 0;\r\n\r\n     for (i = 0; i < nwords; i++) {\r\n          u = 0;\r\n          for (j = 0; j < nwords; j++) {\r\n               MUL(a[i], b[j], UV+1, UV[0]); \r\n               ADDC(0, UV[0], u, carry, v); \r\n               u = UV[1] + carry;\r\n               ADDC(0, c[i+j], v, carry, v); \r\n               u = u + carry;\r\n               c[i+j] = v;\r\n          }\r\n          c[nwords+i] = u;\r\n     }\r\n}\r\n\r\n\r\nvoid mp_mul_comba(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords)\r\n{ // Multiprecision comba multiply, c = a*b, where lng(a) = lng(b) = nwords.   \r\n    unsigned int i, j;\r\n    digit_t t = 0, u = 0, v = 0, UV[2];\r\n    unsigned int carry = 0;\r\n    \r\n    for (i = 0; i < nwords; i++) {\r\n        for (j = 0; j <= i; j++) {\r\n            MUL(a[j], b[i-j], UV+1, UV[0]); \r\n            ADDC(0, UV[0], v, carry, v); \r\n            ADDC(carry, UV[1], u, carry, u); \r\n            t += carry;\r\n        }\r\n        c[i] = v;\r\n        v = u; \r\n        u = t;\r\n        t = 0;\r\n    }\r\n\r\n    for (i = nwords; i < 2*nwords-1; i++) {\r\n        for (j = i-nwords+1; j < nwords; j++) {\r\n            MUL(a[j], b[i-j], UV+1, UV[0]); \r\n            ADDC(0, UV[0], v, carry, v); \r\n            ADDC(carry, UV[1], u, carry, u); \r\n            t += carry;\r\n        }\r\n        c[i] = v;\r\n        v = u; \r\n        u = t;\r\n        t = 0;\r\n    }\r\n    c[2*nwords-1] = v; \r\n}\r\n\r\n\r\nvoid rdc_mont(dfelm_t ma, felm_t mc)\r\n{ // Optimized Montgomery reduction using comba and exploiting the special form of the prime p751.\r\n  // mc = ma*mb*R^-1 mod p751, where ma,mb,mc in [0, p751-1] and R = 2^768.\r\n  // ma and mb are assumed to be in Montgomery representation.\r\n    unsigned int i, j, carry, count = p751_ZERO_WORDS;\r\n    digit_t mask, UV[2], t = 0, u = 0, v = 0, z[NWORDS_FIELD+1] = {0};\r\n\r\n    for (i = 0; i < NWORDS_FIELD; i++) {\r\n        for (j = 0; j < i; j++) {\r\n            if (j < (i-p751_ZERO_WORDS+1)) { \r\n                MUL(z[j], ((digit_t*)p751p1)[i-j], UV+1, UV[0]);\r\n                ADDC(0, UV[0], v, carry, v); \r\n                ADDC(carry, UV[1], u, carry, u); \r\n                t += carry; \r\n            }\r\n        }\r\n        ADDC(0, v, ma[i], carry, v); \r\n        ADDC(carry, u, 0, carry, u); \r\n        t += carry; \r\n        z[i] = v;\r\n        v = u;\r\n        u = t;\r\n        t = 0;\r\n    }    \r\n\r\n    for (i = NWORDS_FIELD; i < 2*NWORDS_FIELD-1; i++) {\r\n        if (count > 0) {\r\n            count -= 1;\r\n        }\r\n        for (j = i-NWORDS_FIELD+1; j < NWORDS_FIELD; j++) {\r\n            if (j < (NWORDS_FIELD-count)) { \r\n                MUL(z[j], ((digit_t*)p751p1)[i-j], UV+1, UV[0]);\r\n                ADDC(0, UV[0], v, carry, v); \r\n                ADDC(carry, UV[1], u, carry, u); \r\n                t += carry;\r\n            }\r\n        }\r\n        ADDC(0, v, ma[i], carry, v); \r\n        ADDC(carry, u, 0, carry, u); \r\n        t += carry; \r\n        z[i-NWORDS_FIELD] = v;\r\n        v = u;\r\n        u = t;\r\n        t = 0;\r\n    }\r\n    ADDC(0, v, ma[2*NWORDS_FIELD-1], carry, v); \r\n    ADDC(carry, u, 0, carry, u); \r\n    t += carry; \r\n    z[NWORDS_FIELD-1] = v;\r\n    z[NWORDS_FIELD] = u;\r\n\r\n    // Final, constant-time subtraction     \r\n    carry = mp_sub(z, (digit_t*)&p751, mc, NWORDS_FIELD);     // (carry, mc) = z - p751\r\n    mask = 0 - (digit_t)carry;                                // if mc < 0 then mask = 0xFF..F, else if mc >= 0 then mask = 0x00..0\r\n\r\n    carry = 0;\r\n    for (i = 0; i < NWORDS_FIELD; i++) {                      // mc = mc + (mask & p751)\r\n        ADDC(carry, mc[i], ((digit_t*)p751)[i] & mask, carry, mc[i]);\r\n    }\r\n\r\n    return;\r\n}","/********************************************************************************************\r\n* SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key \r\n*       exchange providing 128 bits of quantum security and 192 bits of classical security.\r\n*\r\n*    Copyright (c) Microsoft Corporation. All rights reserved.\r\n*\r\n*\r\n* Abstract: internal header file\r\n*\r\n*********************************************************************************************/  \r\n\r\n#ifndef __SIDH_INTERNAL_H__\r\n#define __SIDH_INTERNAL_H__\r\n\r\n\r\n// For C++\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n\r\n#include \"SIDH.h\"   \r\n    \r\n\r\n// Basic constants\r\n\r\n#define ALICE                 0\r\n#define BOB                   1 \r\n#define MAX_INT_POINTS_ALICE  8      \r\n// Fixed parameters for isogeny tree computation    \r\n#define MAX_INT_POINTS_BOB    10 \r\n#define MAX_Alice             185   \r\n#define MAX_Bob               239\r\n   \r\n\r\n// SIDH's basic element definitions and point representations\r\n\r\ntypedef digit_t felm_t[NWORDS_FIELD];                             // Datatype for representing 751-bit field elements (768-bit max.)\r\ntypedef digit_t dfelm_t[2*NWORDS_FIELD];                          // Datatype for representing double-precision 2x751-bit field elements (2x768-bit max.) \r\ntypedef felm_t  f2elm_t[2];                                       // Datatype for representing quadratic extension field elements GF(p751^2)\r\ntypedef f2elm_t publickey_t[4];                                   // Datatype for representing public keys equivalent to four GF(p751^2) elements\r\n        \r\ntypedef struct { f2elm_t x; f2elm_t y; } point_affine;            // Point representation in affine coordinates on Montgomery curve.\r\ntypedef point_affine point_t[1]; \r\n        \r\ntypedef struct { f2elm_t X; f2elm_t Z; } point_proj;              // Point representation in projective XZ Montgomery coordinates.\r\ntypedef point_proj point_proj_t[1]; \r\n        \r\ntypedef struct { felm_t x; felm_t y; } point_basefield_affine;    // Point representation in affine coordinates on Montgomery curve over the base field.\r\ntypedef point_basefield_affine point_basefield_t[1];  \r\n        \r\ntypedef struct { felm_t X; felm_t Z; } point_basefield_proj;      // Point representation in projective XZ Montgomery coordinates over the base field.\r\ntypedef point_basefield_proj point_basefield_proj_t[1]; \r\n    \r\n\r\n// Macro definitions\r\n\r\n#define NBITS_TO_NBYTES(nbits)      (((nbits)+7)/8)                                          // Conversion macro from number of bits to number of bytes\r\n#define NBITS_TO_NWORDS(nbits)      (((nbits)+(sizeof(digit_t)*8)-1)/(sizeof(digit_t)*8))    // Conversion macro from number of bits to number of computer words\r\n#define NBYTES_TO_NWORDS(nbytes)    (((nbytes)+sizeof(digit_t)-1)/sizeof(digit_t))           // Conversion macro from number of bytes to number of computer words\r\n\r\n// Macro to avoid compiler warnings when detecting unreferenced parameters\r\n#define UNREFERENCED_PARAMETER(PAR) (PAR)\r\n\r\n\r\n/********************** Constant-time unsigned comparisons ***********************/\r\n\r\n// The following functions return 1 (TRUE) if condition is true, 0 (FALSE) otherwise\r\n\r\nstatic __inline unsigned int is_digit_nonzero_ct(digit_t x)\r\n{ // Is x != 0?\r\n    return (unsigned int)((x | (0-x)) >> (RADIX-1));\r\n}\r\n\r\nstatic __inline unsigned int is_digit_zero_ct(digit_t x)\r\n{ // Is x = 0?\r\n    return (unsigned int)(1 ^ is_digit_nonzero_ct(x));\r\n}\r\n\r\nstatic __inline unsigned int is_digit_lessthan_ct(digit_t x, digit_t y)\r\n{ // Is x < y?\r\n    return (unsigned int)((x ^ ((x ^ y) | ((x - y) ^ y))) >> (RADIX-1)); \r\n}\r\n\r\n\r\n/********************** Macros for platform-dependent operations **********************/\r\n\r\n#if defined(GENERIC_IMPLEMENTATION)\r\n\r\n// Digit multiplication\r\n#define MUL(multiplier, multiplicand, hi, lo)                                                     \\\r\n    digit_x_digit((multiplier), (multiplicand), &(lo));\r\n    \r\n// Digit addition with carry\r\n#define ADDC(carryIn, addend1, addend2, carryOut, sumOut)                                         \\\r\n    { digit_t tempReg = (addend1) + (digit_t)(carryIn);                                           \\\r\n    (sumOut) = (addend2) + tempReg;                                                               \\\r\n    (carryOut) = (is_digit_lessthan_ct(tempReg, (digit_t)(carryIn)) | is_digit_lessthan_ct((sumOut), tempReg)); }\r\n\r\n// Digit subtraction with borrow\r\n#define SUBC(borrowIn, minuend, subtrahend, borrowOut, differenceOut)                             \\\r\n    { digit_t tempReg = (minuend) - (subtrahend);                                                 \\\r\n    unsigned int borrowReg = (is_digit_lessthan_ct((minuend), (subtrahend)) | ((borrowIn) & is_digit_zero_ct(tempReg)));  \\\r\n    (differenceOut) = tempReg - (digit_t)(borrowIn);                                              \\\r\n    (borrowOut) = borrowReg; }\r\n    \r\n// Shift right with flexible datatype\r\n#define SHIFTR(highIn, lowIn, shift, shiftOut, DigitSize)                                         \\\r\n    (shiftOut) = ((lowIn) >> (shift)) ^ ((highIn) << (DigitSize - (shift)));\r\n    \r\n// Shift left with flexible datatype\r\n#define SHIFTL(highIn, lowIn, shift, shiftOut, DigitSize)                                         \\\r\n    (shiftOut) = ((highIn) << (shift)) ^ ((lowIn) >> (DigitSize - (shift)));\r\n\r\n// 64x64-bit multiplication\r\n#define MUL128(multiplier, multiplicand, product)                                                 \\\r\n    mp_mul((digit_t*)&(multiplier), (digit_t*)&(multiplicand), (digit_t*)&(product), NWORDS_FIELD/2);\r\n\r\n// 128-bit addition, inputs < 2^127\r\n#define ADD128(addend1, addend2, addition)                                                        \\\r\n    mp_add((digit_t*)(addend1), (digit_t*)(addend2), (digit_t*)(addition), NWORDS_FIELD);\r\n\r\n// 128-bit addition with output carry\r\n#define ADC128(addend1, addend2, carry, addition)                                                 \\\r\n    (carry) = mp_add((digit_t*)(addend1), (digit_t*)(addend2), (digit_t*)(addition), NWORDS_FIELD);\r\n\r\n#elif (TARGET == TARGET_AMD64 && OS_TARGET == OS_WIN)\r\n\r\n// Digit multiplication\r\n#define MUL(multiplier, multiplicand, hi, lo)                                                     \\\r\n    (lo) = _umul128((multiplier), (multiplicand), (hi));                \r\n\r\n// Digit addition with carry\r\n#define ADDC(carryIn, addend1, addend2, carryOut, sumOut)                                         \\\r\n    (carryOut) = _addcarry_u64((carryIn), (addend1), (addend2), &(sumOut));\r\n\r\n// Digit subtraction with borrow\r\n#define SUBC(borrowIn, minuend, subtrahend, borrowOut, differenceOut)                             \\\r\n    (borrowOut) = _subborrow_u64((borrowIn), (minuend), (subtrahend), &(differenceOut));\r\n\r\n// Digit shift right\r\n#define SHIFTR(highIn, lowIn, shift, shiftOut, DigitSize)                                         \\\r\n    (shiftOut) = __shiftright128((lowIn), (highIn), (shift));\r\n\r\n// Digit shift left\r\n#define SHIFTL(highIn, lowIn, shift, shiftOut, DigitSize)                                         \\\r\n    (shiftOut) = __shiftleft128((lowIn), (highIn), (shift));\r\n\r\n// 64x64-bit multiplication\r\n#define MUL128(multiplier, multiplicand, product)                                                 \\\r\n    (product)[0] = _umul128((multiplier), (multiplicand), &(product)[1]);\r\n\r\n// 128-bit addition, inputs < 2^127\r\n#define ADD128(addend1, addend2, addition)                                                        \\\r\n    { unsigned char carry = _addcarry_u64(0, (addend1)[0], (addend2)[0], &(addition)[0]);         \\\r\n    _addcarry_u64(carry, (addend1)[1], (addend2)[1], &(addition)[1]); }\r\n\r\n// 128-bit addition with output carry\r\n#define ADC128(addend1, addend2, carry, addition)                                                 \\\r\n    (carry) = _addcarry_u64(0, (addend1)[0], (addend2)[0], &(addition)[0]);                       \\\r\n    (carry) = _addcarry_u64((carry), (addend1)[1], (addend2)[1], &(addition)[1]); \r\n\r\n// 128-bit subtraction, subtrahend < 2^127\r\n#define SUB128(minuend, subtrahend, difference)                                                   \\\r\n    { unsigned char borrow = _subborrow_u64(0, (minuend)[0], (subtrahend)[0], &(difference)[0]);  \\\r\n    _subborrow_u64(borrow, (minuend)[1], (subtrahend)[1], &(difference)[1]); }\r\n\r\n// 128-bit right shift, max. shift value is 64\r\n#define SHIFTR128(Input, shift, shiftOut)                                                         \\\r\n    (shiftOut)[0]  = __shiftright128((Input)[0], (Input)[1], (shift));                            \\\r\n    (shiftOut)[1] = (Input)[1] >> (shift);    \r\n\r\n// 128-bit left shift, max. shift value is 64\r\n#define SHIFTL128(Input, shift, shiftOut)                                                         \\\r\n    (shiftOut)[1]  = __shiftleft128((Input)[0], (Input)[1], (shift));                             \\\r\n    (shiftOut)[0] = (Input)[0] << (shift);  \r\n\r\n#define MULADD128(multiplier, multiplicand, addend, carry, result);    \\\r\n    { uint128_t product;                                               \\\r\n      MUL128(multiplier, multiplicand, product);                       \\\r\n      ADC128(addend, product, carry, result); }   \r\n\r\n#elif (TARGET == TARGET_AMD64 && OS_TARGET == OS_LINUX)\r\n\r\n// Digit multiplication\r\n#define MUL(multiplier, multiplicand, hi, lo)                                                     \\\r\n    { uint128_t tempReg = (uint128_t)(multiplier) * (uint128_t)(multiplicand);                    \\\r\n    *(hi) = (digit_t)(tempReg >> RADIX);                                                          \\\r\n    (lo) = (digit_t)tempReg; }\r\n\r\n// Digit addition with carry\r\n#define ADDC(carryIn, addend1, addend2, carryOut, sumOut)                                         \\\r\n    { uint128_t tempReg = (uint128_t)(addend1) + (uint128_t)(addend2) + (uint128_t)(carryIn);     \\\r\n    (carryOut) = (digit_t)(tempReg >> RADIX);                                                     \\\r\n    (sumOut) = (digit_t)tempReg; }  \r\n    \r\n// Digit subtraction with borrow\r\n#define SUBC(borrowIn, minuend, subtrahend, borrowOut, differenceOut)                             \\\r\n    { uint128_t tempReg = (uint128_t)(minuend) - (uint128_t)(subtrahend) - (uint128_t)(borrowIn); \\\r\n    (borrowOut) = (digit_t)(tempReg >> (sizeof(uint128_t)*8 - 1));                                \\\r\n    (differenceOut) = (digit_t)tempReg; }\r\n\r\n// Digit shift right\r\n#define SHIFTR(highIn, lowIn, shift, shiftOut, DigitSize)                                         \\\r\n    (shiftOut) = ((lowIn) >> (shift)) ^ ((highIn) << (RADIX - (shift)));\r\n\r\n// Digit shift left\r\n#define SHIFTL(highIn, lowIn, shift, shiftOut, DigitSize)                                         \\\r\n    (shiftOut) = ((highIn) << (shift)) ^ ((lowIn) >> (RADIX - (shift)));\r\n\r\n#endif\r\n\r\n\r\n// Multiprecision multiplication selection\r\n#if (TARGET == TARGET_AMD64)\r\n    #define mp_mul_comba         mp_mul\r\n#else\r\n    #define mp_mul_schoolbook    mp_mul\r\n#endif\r\n\r\n\r\n\r\n/**************** Function prototypes ****************/\r\n/************* Multiprecision functions **************/ \r\n\r\n// Copy wordsize digits, c = a, where lng(a) = nwords\r\nvoid copy_words(digit_t* a, digit_t* c, unsigned int nwords);\r\n\r\n// Multiprecision addition, c = a+b, where lng(a) = lng(b) = nwords. Returns the carry bit \r\nextern unsigned int mp_add(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords);\r\n\r\n// Multiprecision subtraction, c = a-b, where lng(a) = lng(b) = nwords. Returns the borrow bit \r\nextern unsigned int mp_sub(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords);\r\n\r\n// Multiprecision right shift by one\r\nvoid mp_shiftr1(digit_t* x, unsigned int nwords);\r\n\r\n// Multiprecision left right shift by one    \r\nvoid mp_shiftl1(digit_t* x, unsigned int nwords);\r\n\r\n// Digit multiplication, digit * digit -> 2-digit result\r\nvoid digit_x_digit(digit_t a, digit_t b, digit_t* c);    \r\n\r\n// Multiprecision schoolbook multiply, c = a*b, where lng(a) = lng(b) = nwords.\r\nvoid mp_mul_schoolbook(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords);\r\n\r\n// Multiprecision comba multiply, c = a*b, where lng(a) = lng(b) = nwords.\r\nvoid mp_mul_comba(digit_t* a, digit_t* b, digit_t* c, unsigned int nwords);\r\n\r\n/************ Field arithmetic functions *************/\r\n\r\n// Copy of a field element, c = a\r\nvoid fpcopy751(felm_t a, felm_t c);\r\n\r\n// Zeroing a field element, a = 0\r\nvoid fpzero751(felm_t a);\r\n\r\n// Modular addition, c = a+b mod p751\r\nextern void fpadd751(digit_t* a, digit_t* b, digit_t* c);\r\nextern void fpadd751_asm(digit_t* a, digit_t* b, digit_t* c);\r\n\r\n// Modular subtraction, c = a-b mod p751\r\nextern void fpsub751(digit_t* a, digit_t* b, digit_t* c);\r\nextern void fpsub751_asm(digit_t* a, digit_t* b, digit_t* c);\r\n\r\n// Modular negation, a = -a mod p751        \r\nextern void fpneg751(digit_t* a);  \r\n\r\n// Modular division by two, c = a/2 mod p751.\r\nvoid fpdiv2_751(digit_t* a, digit_t* c);\r\n\r\n// 751-bit Montgomery reduction, c = a mod p\r\nvoid rdc_mont(digit_t* a, digit_t* c);\r\n            \r\n// Field multiplication using Montgomery arithmetic, c = a*b*R^-1 mod p751, where R=2^768\r\nvoid fpmul751_mont(felm_t a, felm_t b, felm_t c);\r\nvoid mul751_asm(felm_t a, felm_t b, dfelm_t c);\r\nvoid rdc751_asm(dfelm_t ma, dfelm_t mc);\r\n   \r\n// Field squaring using Montgomery arithmetic, c = a*b*R^-1 mod p751, where R=2^768\r\nvoid fpsqr751_mont(felm_t ma, felm_t mc);\r\n\r\n// Conversion to Montgomery representation\r\nvoid to_mont(felm_t a, felm_t mc);\r\n    \r\n// Conversion from Montgomery representation to standard representation\r\nvoid from_mont(felm_t ma, felm_t c);\r\n\r\n// Field inversion, a = a^-1 in GF(p751)\r\nvoid fpinv751_mont(felm_t a);\r\n\r\n/************ GF(p^2) arithmetic functions *************/\r\n    \r\n// Copy of a GF(p751^2) element, c = a\r\nvoid fp2copy751(f2elm_t a, f2elm_t c);\r\n\r\n// Zeroing a GF(p751^2) element, a = 0\r\nvoid fp2zero751(f2elm_t a);\r\n\r\n// GF(p751^2) negation, a = -a in GF(p751^2)\r\nvoid fp2neg751(f2elm_t a);\r\n\r\n// GF(p751^2) addition, c = a+b in GF(p751^2)\r\nextern void fp2add751(f2elm_t a, f2elm_t b, f2elm_t c);           \r\n\r\n// GF(p751^2) subtraction, c = a-b in GF(p751^2)\r\nextern void fp2sub751(f2elm_t a, f2elm_t b, f2elm_t c); \r\n\r\n// GF(p751^2) division by two, c = a/2  in GF(p751^2) \r\nvoid fp2div2_751(f2elm_t a, f2elm_t c);\r\n            \r\n// GF(p751^2) squaring using Montgomery arithmetic, c = a^2 in GF(p751^2)\r\nvoid fp2sqr751_mont(f2elm_t a, f2elm_t c);\r\n \r\n// GF(p751^2) multiplication using Montgomery arithmetic, c = a*b in GF(p751^2)\r\nvoid fp2mul751_mont(f2elm_t a, f2elm_t b, f2elm_t c);\r\n    \r\n// Conversion of a GF(p751^2) element to Montgomery representation\r\nvoid to_fp2mont(f2elm_t a, f2elm_t mc);\r\n\r\n// Conversion of a GF(p751^2) element from Montgomery representation to standard representation\r\nvoid from_fp2mont(f2elm_t ma, f2elm_t c);\r\n\r\n// GF(p751^2) inversion using Montgomery arithmetic, a = (a0-i*a1)/(a0^2+a1^2)\r\nvoid fp2inv751_mont(f2elm_t a);\r\n\r\n// Select either x or y depending on value of option \r\nvoid select_f2elm(f2elm_t x, f2elm_t y, f2elm_t z, digit_t option);\r\n\r\n/************ Elliptic curve and isogeny functions *************/\r\n\r\n// Check if curve isogeny structure is NULL\r\nbool is_CurveIsogenyStruct_null(PCurveIsogenyStruct pCurveIsogeny);\r\n\r\n// Swap points over the base field \r\nvoid swap_points_basefield(point_basefield_proj_t P, point_basefield_proj_t Q, digit_t option);\r\n\r\n// Swap points\r\nvoid swap_points(point_proj_t P, point_proj_t Q, digit_t option);\r\n\r\n// Computes the j-invariant of a Montgomery curve with projective constant.\r\nvoid j_inv(f2elm_t A, f2elm_t C, f2elm_t jinv);\r\n\r\n// Simultaneous doubling and differential addition.\r\nvoid xDBLADD(point_proj_t P, point_proj_t Q, f2elm_t xPQ, f2elm_t A24);\r\n\r\n// Doubling of a Montgomery point in projective coordinates (X:Z).\r\nvoid xDBL(point_proj_t P, point_proj_t Q, f2elm_t A24, f2elm_t C24);\r\n\r\n// Computes [2^e](X:Z) on Montgomery curve with projective constant via e repeated doublings.\r\nvoid xDBLe(point_proj_t P, point_proj_t Q, f2elm_t A, f2elm_t C, int e);\r\n\r\n// Computes [2^e](X:Z) on Montgomery curve with projective constant via e repeated doublings and collects a few intermediate multiples.\r\nvoid xDBLe_collect(point_proj_t P, point_proj_t Q, f2elm_t A, f2elm_t C, unsigned int left_bound, const unsigned int right_bound, const unsigned int* col, point_proj_t* pts, unsigned int* pts_index, unsigned int *npts);\r\n\r\n// Differential addition.\r\nvoid xADD(point_proj_t P, point_proj_t Q, f2elm_t xPQ);\r\n\r\n// Doubling of a Montgomery point in projective coordinates (X:Z) over the base field.\r\nvoid xDBL_basefield(point_basefield_proj_t P, point_basefield_proj_t Q);\r\n\r\n// Simultaneous doubling and differential addition over the base field.\r\nvoid xDBLADD_basefield(point_basefield_proj_t P, point_basefield_proj_t Q, felm_t xPQ, felm_t A24);\r\n\r\n// The Montgomery ladder\r\nvoid ladder(felm_t x, digit_t* m, point_basefield_proj_t P, point_basefield_proj_t Q, felm_t A24, unsigned int order_bits, unsigned int order_fullbits, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// Computes key generation entirely in the base field\r\nCRYPTO_STATUS secret_pt(point_basefield_t P, digit_t* m, unsigned int AliceOrBob, point_proj_t R, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// Computes P+[m]Q via x-only arithmetic.\r\nCRYPTO_STATUS ladder_3_pt(f2elm_t xP, f2elm_t xQ, f2elm_t xPQ, digit_t* m, unsigned int AliceOrBob, point_proj_t W, f2elm_t A, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// Computes the corresponding 4-isogeny of a projective Montgomery point (X4:Z4) of order 4.\r\nvoid get_4_isog(point_proj_t P, f2elm_t A, f2elm_t C, f2elm_t* coeff);\r\n\r\n// Evaluates the isogeny at the point (X:Z) in the domain of the isogeny\r\nvoid eval_4_isog(point_proj_t P, f2elm_t* coeff);\r\n\r\n// Computes first 4-isogeny computed by Alice.\r\nvoid first_4_isog(point_proj_t P, f2elm_t A, f2elm_t Aout, f2elm_t Cout, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n// Tripling of a Montgomery point in projective coordinates (X:Z).\r\nvoid xTPL(point_proj_t P, point_proj_t Q, f2elm_t A, f2elm_t C);\r\n\r\n// Computes [3^e](X:Z) on Montgomery curve with projective constant via e repeated triplings.\r\nvoid xTPLe(point_proj_t P, point_proj_t Q, f2elm_t A, f2elm_t C, int e);\r\n\r\n// Computes [3^e](X:Z) on Montgomery curve with projective constant via e repeated triplings and collects a few intermediate multiples.    \r\nvoid xTPLe_collect(point_proj_t P, point_proj_t Q, f2elm_t A, f2elm_t C, unsigned int left_bound, const unsigned int right_bound, const unsigned int* col, point_proj_t* pts, unsigned int* pts_index, unsigned int *npts);\r\n\r\n// Computes the corresponding 3-isogeny of a projective Montgomery point (X3:Z3) of order 3.\r\nvoid get_3_isog(point_proj_t P, f2elm_t A, f2elm_t C);\r\n\r\n// Computes the 3-isogeny R=phi(X:Z), given projective point (X3:Z3) of order 3 on a Montgomery curve and a point P = (X:Z).\r\nvoid eval_3_isog(point_proj_t P, point_proj_t Q);\r\n\r\n// 4-way simultaneous inversion\r\nvoid inv_4_way(f2elm_t z1, f2elm_t z2, f2elm_t z3, f2elm_t z4);\r\n\r\n// Computing the point D = (x(Q-P),z(Q-P))\r\nvoid distort_and_diff(felm_t xP, point_proj_t d, PCurveIsogenyStruct CurveIsogeny);\r\n\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n\r\n#endif\r\n","/********************************************************************************************\r\n* SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key \r\n*       exchange providing 128 bits of quantum security and 192 bits of classical security.\r\n*\r\n*    Copyright (c) Microsoft Corporation. All rights reserved.\r\n*\r\n*\r\n* Abstract: isogeny-based key exchange\r\n*\r\n*********************************************************************************************/ \r\n\r\n#include \"SIDH_internal.h\"\r\n\r\nextern const unsigned int splits_Alice[MAX_Alice];\r\nextern const unsigned int splits_Bob[MAX_Bob];\r\n\r\n\r\nCRYPTO_STATUS KeyGeneration_A(unsigned char* pPrivateKeyA, unsigned char* pPublicKeyA, PCurveIsogenyStruct CurveIsogeny)\r\n{ // Alice's key-pair generation\r\n  // It produces a private key pPrivateKeyA and computes the public key pPublicKeyA.\r\n  // The private key is an even integer in the range [2, oA-2], where oA = 2^372 (i.e., 372 bits in total). \r\n  // The public key consists of 4 elements in GF(p751^2), i.e., 751 bytes in total.\r\n  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().\r\n    unsigned int owords = NBITS_TO_NWORDS(CurveIsogeny->owordbits), pwords = NBITS_TO_NWORDS(CurveIsogeny->pwordbits);\r\n    point_basefield_t P;\r\n    point_proj_t R, phiP = {0}, phiQ = {0}, phiD = {0}, pts[MAX_INT_POINTS_ALICE];\r\n    publickey_t* PublicKeyA = (publickey_t*)pPublicKeyA;\r\n    unsigned int i, row, m, index = 0, pts_index[MAX_INT_POINTS_ALICE], npts = 0; \r\n    f2elm_t coeff[5], A = {0}, C = {0}, Aout, Cout;\r\n    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN; \r\n\r\n    if (pPrivateKeyA == NULL || pPublicKeyA == NULL || is_CurveIsogenyStruct_null(CurveIsogeny)) {\r\n        return CRYPTO_ERROR_INVALID_PARAMETER;\r\n    }  \r\n\r\n    // Choose a random even number in the range [2, oA-2] as secret key for Alice\r\n    Status = random_mod_order((digit_t*)pPrivateKeyA, ALICE, CurveIsogeny);    \r\n    if (Status != CRYPTO_SUCCESS) {\r\n        clear_words((void*)pPrivateKeyA, owords);\r\n        return Status;\r\n    }\r\n\r\n    to_mont((digit_t*)CurveIsogeny->PA, (digit_t*)P);                               // Conversion of Alice's generators to Montgomery representation\r\n    to_mont(((digit_t*)CurveIsogeny->PA)+NWORDS_FIELD, ((digit_t*)P)+NWORDS_FIELD); \r\n\r\n    Status = secret_pt(P, (digit_t*)pPrivateKeyA, ALICE, R, CurveIsogeny);\r\n    if (Status != CRYPTO_SUCCESS) {\r\n        clear_words((void*)pPrivateKeyA, owords);\r\n        return Status;\r\n    }\r\n\r\n    copy_words((digit_t*)CurveIsogeny->PB, (digit_t*)phiP, pwords);                 // Copy X-coordinates from Bob's public parameters, set Z <- 1\r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)phiP->Z);  \r\n    to_mont((digit_t*)phiP, (digit_t*)phiP);                                        \r\n    copy_words((digit_t*)phiP, (digit_t*)phiQ, pwords);                             // QB = (-XPB:1)\r\n    fpneg751(phiQ->X[0]);   \r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)phiQ->Z); \r\n    distort_and_diff(phiP->X[0], phiD, CurveIsogeny);                               // DB = (x(QB-PB),z(QB-PB))\r\n\r\n    fpcopy751(CurveIsogeny->A, A[0]);                                               // Extracting curve parameters A and C\r\n    fpcopy751(CurveIsogeny->C, C[0]);\r\n    to_mont(A[0], A[0]);\r\n    to_mont(C[0], C[0]);\r\n\r\n    first_4_isog(phiP, A, Aout, Cout, CurveIsogeny);     \r\n    first_4_isog(phiQ, A, Aout, Cout, CurveIsogeny);\r\n    first_4_isog(phiD, A, Aout, Cout, CurveIsogeny);\r\n    first_4_isog(R, A, A, C, CurveIsogeny);\r\n    \r\n    index = 0;        \r\n    for (row = 1; row < MAX_Alice; row++) {\r\n        while (index < MAX_Alice-row) {\r\n            fp2copy751(R->X, pts[npts]->X);\r\n            fp2copy751(R->Z, pts[npts]->Z);\r\n            pts_index[npts] = index;\r\n            npts += 1;\r\n            m = splits_Alice[MAX_Alice-index-row];\r\n            xDBLe(R, R, A, C, (int)(2*m));\r\n            index += m;\r\n        }\r\n        get_4_isog(R, A, C, coeff);        \r\n\r\n        for (i = 0; i < npts; i++) {\r\n            eval_4_isog(pts[i], coeff);\r\n        }\r\n        eval_4_isog(phiP, coeff);\r\n        eval_4_isog(phiQ, coeff);\r\n        eval_4_isog(phiD, coeff);\r\n\r\n        fp2copy751(pts[npts-1]->X, R->X); \r\n        fp2copy751(pts[npts-1]->Z, R->Z);\r\n        index = pts_index[npts-1];\r\n        npts -= 1;\r\n    }\r\n\r\n    get_4_isog(R, A, C, coeff); \r\n    eval_4_isog(phiP, coeff);\r\n    eval_4_isog(phiQ, coeff);\r\n    eval_4_isog(phiD, coeff);\r\n\r\n    inv_4_way(C, phiP->Z, phiQ->Z, phiD->Z);\r\n    fp2mul751_mont(A, C, A);\r\n    fp2mul751_mont(phiP->X, phiP->Z, phiP->X);\r\n    fp2mul751_mont(phiQ->X, phiQ->Z, phiQ->X);\r\n    fp2mul751_mont(phiD->X, phiD->Z, phiD->X);\r\n\r\n    from_fp2mont(A, ((f2elm_t*)PublicKeyA)[0]);                                     // Converting back to standard representation\r\n    from_fp2mont(phiP->X, ((f2elm_t*)PublicKeyA)[1]);\r\n    from_fp2mont(phiQ->X, ((f2elm_t*)PublicKeyA)[2]);\r\n    from_fp2mont(phiD->X, ((f2elm_t*)PublicKeyA)[3]);\r\n\r\n// Cleanup:\r\n    clear_words((void*)R, 2*2*pwords);\r\n    clear_words((void*)phiP, 2*2*pwords);\r\n    clear_words((void*)phiQ, 2*2*pwords);\r\n    clear_words((void*)phiD, 2*2*pwords);\r\n    clear_words((void*)pts, MAX_INT_POINTS_ALICE*2*2*pwords);\r\n    clear_words((void*)A, 2*pwords);\r\n    clear_words((void*)C, 2*pwords);\r\n    clear_words((void*)coeff, 5*2*pwords);\r\n      \r\n    return Status;\r\n}\r\n\r\n\r\nCRYPTO_STATUS KeyGeneration_B(unsigned char* pPrivateKeyB, unsigned char* pPublicKeyB, PCurveIsogenyStruct CurveIsogeny)\r\n{ // Bob's key-pair generation\r\n  // It produces a private key pPrivateKeyB and computes the public key pPublicKeyB.\r\n  // The private key is an integer in the range [1, oB-1], where oA = 3^239 (i.e., 379 bits in total). \r\n  // The public key consists of 4 elements in GF(p751^2), i.e., 751 bytes in total.\r\n  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().\r\n    unsigned int owords = NBITS_TO_NWORDS(CurveIsogeny->owordbits), pwords = NBITS_TO_NWORDS(CurveIsogeny->pwordbits);\r\n    point_basefield_t P;\r\n    point_proj_t R, phiP = {0}, phiQ = {0}, phiD = {0}, pts[MAX_INT_POINTS_BOB];\r\n    publickey_t* PublicKeyB = (publickey_t*)pPublicKeyB;\r\n    unsigned int i, row, m, index = 0, pts_index[MAX_INT_POINTS_BOB], npts = 0; \r\n    f2elm_t A = {0}, C = {0};\r\n    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN;  \r\n\r\n    if (pPrivateKeyB == NULL || pPublicKeyB == NULL || is_CurveIsogenyStruct_null(CurveIsogeny)) {\r\n        return CRYPTO_ERROR_INVALID_PARAMETER;\r\n    }  \r\n\r\n    // Choose a random number equivalent to 0 (mod 3) in the range [3, oB-3] as secret key for Bob\r\n    Status = random_mod_order((digit_t*)pPrivateKeyB, BOB, CurveIsogeny);\r\n    if (Status != CRYPTO_SUCCESS) {\r\n        clear_words((void*)pPrivateKeyB, owords);\r\n        return Status;\r\n    }\r\n\r\n    to_mont((digit_t*)CurveIsogeny->PB, (digit_t*)P);                               // Conversion of Bob's generators to Montgomery representation\r\n    to_mont(((digit_t*)CurveIsogeny->PB)+NWORDS_FIELD, ((digit_t*)P)+NWORDS_FIELD); \r\n\r\n    Status = secret_pt(P, (digit_t*)pPrivateKeyB, BOB, R, CurveIsogeny);\r\n    if (Status != CRYPTO_SUCCESS) {\r\n        clear_words((void*)pPrivateKeyB, owords);\r\n        return Status;\r\n    }\r\n\r\n    copy_words((digit_t*)CurveIsogeny->PA, (digit_t*)phiP, pwords);                 // Copy X-coordinates from Alice's public parameters, set Z <- 1\r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)phiP->Z);   \r\n    to_mont((digit_t*)phiP, (digit_t*)phiP);                                        // Conversion to Montgomery representation\r\n    copy_words((digit_t*)phiP, (digit_t*)phiQ, pwords);                             // QA = (-XPA:1)\r\n    fpneg751(phiQ->X[0]); \r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, (digit_t*)phiQ->Z);  \r\n    distort_and_diff(phiP->X[0], phiD, CurveIsogeny);                               // DA = (x(QA-PA),z(QA-PA))\r\n\r\n    fpcopy751(CurveIsogeny->A, A[0]);                                               // Extracting curve parameters A and C\r\n    fpcopy751(CurveIsogeny->C, C[0]);\r\n    to_mont(A[0], A[0]);\r\n    to_mont(C[0], C[0]);\r\n    \r\n    index = 0;  \r\n    for (row = 1; row < MAX_Bob; row++) {\r\n        while (index < MAX_Bob-row) {\r\n            fp2copy751(R->X, pts[npts]->X);\r\n            fp2copy751(R->Z, pts[npts]->Z);\r\n            pts_index[npts] = index;\r\n            npts += 1;\r\n            m = splits_Bob[MAX_Bob-index-row];\r\n            xTPLe(R, R, A, C, (int)m);\r\n            index += m;\r\n        }\r\n        get_3_isog(R, A, C);        \r\n\r\n        for (i = 0; i < npts; i++) {\r\n            eval_3_isog(R, pts[i]);\r\n        }     \r\n        eval_3_isog(R, phiP);\r\n        eval_3_isog(R, phiQ);\r\n        eval_3_isog(R, phiD);\r\n\r\n        fp2copy751(pts[npts-1]->X, R->X); \r\n        fp2copy751(pts[npts-1]->Z, R->Z);\r\n        index = pts_index[npts-1];\r\n        npts -= 1;\r\n    }\r\n    \r\n    get_3_isog(R, A, C);    \r\n    eval_3_isog(R, phiP);\r\n    eval_3_isog(R, phiQ);\r\n    eval_3_isog(R, phiD);\r\n\r\n    inv_4_way(C, phiP->Z, phiQ->Z, phiD->Z);\r\n    fp2mul751_mont(A, C, A);\r\n    fp2mul751_mont(phiP->X, phiP->Z, phiP->X);\r\n    fp2mul751_mont(phiQ->X, phiQ->Z, phiQ->X);\r\n    fp2mul751_mont(phiD->X, phiD->Z, phiD->X);\r\n\r\n    from_fp2mont(A, ((f2elm_t*)PublicKeyB)[0]);                                     // Converting back to standard representation\r\n    from_fp2mont(phiP->X, ((f2elm_t*)PublicKeyB)[1]);\r\n    from_fp2mont(phiQ->X, ((f2elm_t*)PublicKeyB)[2]);\r\n    from_fp2mont(phiD->X, ((f2elm_t*)PublicKeyB)[3]);\r\n\r\n// Cleanup:\r\n    clear_words((void*)R, 2*2*pwords);\r\n    clear_words((void*)phiP, 2*2*pwords);\r\n    clear_words((void*)phiQ, 2*2*pwords);\r\n    clear_words((void*)phiD, 2*2*pwords);\r\n    clear_words((void*)pts, MAX_INT_POINTS_BOB*2*2*pwords);\r\n    clear_words((void*)A, 2*pwords);\r\n    clear_words((void*)C, 2*pwords);\r\n      \r\n    return Status;\r\n}\r\n\r\n\r\nCRYPTO_STATUS SecretAgreement_A(unsigned char* pPrivateKeyA, unsigned char* pPublicKeyB, unsigned char* pSharedSecretA, PCurveIsogenyStruct CurveIsogeny)\r\n{ // Alice's shared secret generation\r\n  // It produces a shared secret key pSharedSecretA using her secret key pPrivateKeyA and Bob's public key pPublicKeyB\r\n  // Inputs: Alice's pPrivateKeyA is an even integer in the range [2, oA-2], where oA = 2^372 (i.e., 372 bits in total). \r\n  //         Bob's pPublicKeyB consists of 4 elements in GF(p751^2), i.e., 751 bytes in total.\r\n  // Output: a shared secret pSharedSecretA that consists of one element in GF(p751^2), i.e., 1502 bits in total. \r\n  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().\r\n    unsigned int pwords = NBITS_TO_NWORDS(CurveIsogeny->pwordbits);\r\n    unsigned int i, row, m, index = 0, pts_index[MAX_INT_POINTS_ALICE], npts = 0; \r\n    point_proj_t R, pts[MAX_INT_POINTS_ALICE];\r\n    publickey_t* PublicKeyB = (publickey_t*)pPublicKeyB;\r\n    f2elm_t jinv, coeff[5], A, C = {0}, PKB2, PKB3, PKB4;\r\n    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN;  \r\n\r\n    if (pPrivateKeyA == NULL || pPublicKeyB == NULL || pSharedSecretA == NULL || is_CurveIsogenyStruct_null(CurveIsogeny)) {\r\n        return CRYPTO_ERROR_INVALID_PARAMETER;\r\n    }\r\n\r\n    to_fp2mont(((f2elm_t*)PublicKeyB)[0], A);         // Extracting and converting Bob's public curve parameters to Montgomery representation\r\n    to_fp2mont(((f2elm_t*)PublicKeyB)[1], PKB2);\r\n    to_fp2mont(((f2elm_t*)PublicKeyB)[2], PKB3);        \r\n    to_fp2mont(((f2elm_t*)PublicKeyB)[3], PKB4);\r\n\r\n    fpcopy751(CurveIsogeny->C, C[0]);\r\n    to_mont(C[0], C[0]);\r\n\r\n    Status = ladder_3_pt(PKB2, PKB3, PKB4, (digit_t*)pPrivateKeyA, ALICE, R, A, CurveIsogeny);\r\n    if (Status != CRYPTO_SUCCESS) {\r\n        return Status;\r\n    }\r\n    first_4_isog(R, A, A, C, CurveIsogeny); \r\n        \r\n    index = 0;  \r\n    for (row = 1; row < MAX_Alice; row++) {\r\n        while (index < MAX_Alice-row) {\r\n            fp2copy751(R->X, pts[npts]->X);\r\n            fp2copy751(R->Z, pts[npts]->Z);\r\n            pts_index[npts] = index;\r\n            npts += 1;\r\n            m = splits_Alice[MAX_Alice-index-row];\r\n            xDBLe(R, R, A, C, (int)(2*m));\r\n            index += m;\r\n        }\r\n        get_4_isog(R, A, C, coeff);        \r\n\r\n        for (i = 0; i < npts; i++) {\r\n            eval_4_isog(pts[i], coeff);\r\n        }\r\n\r\n        fp2copy751(pts[npts-1]->X, R->X); \r\n        fp2copy751(pts[npts-1]->Z, R->Z);\r\n        index = pts_index[npts-1];\r\n        npts -= 1;\r\n    }\r\n    \r\n    get_4_isog(R, A, C, coeff); \r\n    j_inv(A, C, jinv);\r\n    from_fp2mont(jinv, (felm_t*)pSharedSecretA);      // Converting back to standard representation\r\n\r\n// Cleanup:\r\n    clear_words((void*)R, 2*2*pwords);\r\n    clear_words((void*)pts, MAX_INT_POINTS_ALICE*2*2*pwords);\r\n    clear_words((void*)A, 2*pwords);\r\n    clear_words((void*)C, 2*pwords);\r\n    clear_words((void*)jinv, 2*pwords);\r\n    clear_words((void*)coeff, 5*2*pwords);\r\n      \r\n    return Status;\r\n}\r\n\r\n\r\nCRYPTO_STATUS SecretAgreement_B(unsigned char* pPrivateKeyB, unsigned char* pPublicKeyA, unsigned char* pSharedSecretB, PCurveIsogenyStruct CurveIsogeny)\r\n{ // Bob's shared secret generation\r\n  // It produces a shared secret key pSharedSecretB using his secret key pPrivateKeyB and Alice's public key pPublicKeyA\r\n  // Inputs: Bob's pPrivateKeyB is an integer in the range [1, oB-1], where oA = 3^239 (i.e., 379 bits in total). \r\n  //         Alice's pPublicKeyA consists of 4 elements in GF(p751^2), i.e., 751 bytes in total.\r\n  // Output: a shared secret pSharedSecretB that consists of one element in GF(p751^2), i.e., 1502 bits in total. \r\n  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().\r\n    unsigned int pwords = NBITS_TO_NWORDS(CurveIsogeny->pwordbits);\r\n    unsigned int i, row, m, index = 0, pts_index[MAX_INT_POINTS_BOB], npts = 0; \r\n    point_proj_t R, pts[MAX_INT_POINTS_BOB];\r\n    publickey_t* PublicKeyA = (publickey_t*)pPublicKeyA;\r\n    f2elm_t jinv, A, C = {0}, PKA2, PKA3, PKA4;\r\n    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN;  \r\n\r\n    if (pPrivateKeyB == NULL || pPublicKeyA == NULL || pSharedSecretB == NULL || is_CurveIsogenyStruct_null(CurveIsogeny)) {\r\n        return CRYPTO_ERROR_INVALID_PARAMETER;\r\n    }\r\n\r\n    to_fp2mont(((f2elm_t*)PublicKeyA)[0], A);         // Extracting and converting Alice's public curve parameters to Montgomery representation\r\n    to_fp2mont(((f2elm_t*)PublicKeyA)[1], PKA2);\r\n    to_fp2mont(((f2elm_t*)PublicKeyA)[2], PKA3);       \r\n    to_fp2mont(((f2elm_t*)PublicKeyA)[3], PKA4);\r\n\r\n    fpcopy751(CurveIsogeny->C, C[0]);\r\n    to_mont(C[0], C[0]);\r\n\r\n    Status = ladder_3_pt(PKA2, PKA3, PKA4, (digit_t*)pPrivateKeyB, BOB, R, A, CurveIsogeny);\r\n    if (Status != CRYPTO_SUCCESS) {\r\n        return Status;\r\n    }\r\n    \r\n    index = 0;  \r\n    for (row = 1; row < MAX_Bob; row++) {\r\n        while (index < MAX_Bob-row) {\r\n            fp2copy751(R->X, pts[npts]->X);\r\n            fp2copy751(R->Z, pts[npts]->Z);\r\n            pts_index[npts] = index;\r\n            npts += 1;\r\n            m = splits_Bob[MAX_Bob-index-row];\r\n            xTPLe(R, R, A, C, (int)m);\r\n            index += m;\r\n        }\r\n        get_3_isog(R, A, C);        \r\n\r\n        for (i = 0; i < npts; i++) {\r\n            eval_3_isog(R, pts[i]);\r\n        } \r\n\r\n        fp2copy751(pts[npts-1]->X, R->X); \r\n        fp2copy751(pts[npts-1]->Z, R->Z);\r\n        index = pts_index[npts-1];\r\n        npts -= 1;\r\n    }\r\n    \r\n    get_3_isog(R, A, C);    \r\n    j_inv(A, C, jinv);\r\n    from_fp2mont(jinv, (felm_t*)pSharedSecretB);      // Converting back to standard representation\r\n\r\n// Cleanup:\r\n    clear_words((void*)R, 2*2*pwords);\r\n    clear_words((void*)pts, MAX_INT_POINTS_BOB*2*2*pwords);\r\n    clear_words((void*)A, 2*pwords);\r\n    clear_words((void*)C, 2*pwords);\r\n    clear_words((void*)jinv, 2*pwords);\r\n      \r\n    return Status;\r\n}\r\n","/********************************************************************************************\r\n* SIDH: an efficient supersingular isogeny-based cryptography library for Diffie-Hellman key \r\n*       exchange providing 128 bits of quantum security and 192 bits of classical security.\r\n*\r\n*    Copyright (c) Microsoft Corporation. All rights reserved.\r\n*\r\n*\r\n* Abstract: functions for validation of public keys\r\n*           \r\n* SECURITY NOTE: these functions run in variable time because it is assumed that they are\r\n*                used over public data.\r\n*\r\n*********************************************************************************************/ \r\n\r\n#include \"SIDH_internal.h\"\r\n\r\n\r\nstatic bool is_equal_fp(felm_t a, felm_t b)\r\n{ // Return true if a = b in GF(p751). Otherwise, return false\r\n    unsigned int i;\r\n\r\n    for (i = 0; i < NWORDS_FIELD; i++) {\r\n        if (a[i] != b[i]) {\r\n            return false; \r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\nstatic bool is_equal_fp2(f2elm_t a, f2elm_t b)\r\n{ // Return true if a = b in GF(p751^2). Otherwise, return false\r\n\r\n    return (is_equal_fp(a[0], b[0]) && is_equal_fp(a[1], b[1]));\r\n}\r\n\r\n\r\nCRYPTO_STATUS random_fp2(f2elm_t f2value, PCurveIsogenyStruct pCurveIsogeny)\r\n{ // Output random value in GF(p751). It makes requests of random values to the \"random_bytes\" function. \r\n  // If successful, the output is given in \"f2value\".\r\n  // The \"random_bytes\" function, which is passed through the curve isogeny structure PCurveIsogeny, should be set up in advance using SIDH_curve_initialize().\r\n  // The caller is responsible of providing the \"random_bytes\" function passing random values as octets.\r\n    unsigned int ntry = 0, nbytes;    \r\n    felm_t t1, p751;\r\n    unsigned char mask;\r\n    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN;\r\n    \r\n    clear_words((void*)f2value, 2*NWORDS_FIELD);    \r\n    fpcopy751(pCurveIsogeny->prime, p751);\r\n    nbytes = (pCurveIsogeny->pbits+7)/8;                       // Number of random bytes to be requested \r\n    mask = (unsigned char)(8*nbytes - pCurveIsogeny->pbits);\r\n    mask = ((unsigned char)-1 >> mask);                        // Value for masking last random byte\r\n\r\n    do {\r\n        ntry++;\r\n        if (ntry > 100) {                                      // Max. 100 iterations to obtain random value in [0, p751-1] \r\n            return CRYPTO_ERROR_TOO_MANY_ITERATIONS;\r\n        }\r\n        Status = (pCurveIsogeny->RandomBytesFunction)(nbytes, (unsigned char*)&f2value[0]);\r\n        if (Status != CRYPTO_SUCCESS) {\r\n            return Status;\r\n        }\r\n        ((unsigned char*)&f2value[0])[nbytes-1] &= mask;       // Masking last byte \r\n    } while (mp_sub(p751, f2value[0], t1, NWORDS_FIELD) == 1);\r\n\r\n    ntry = 0;\r\n    do {\r\n        ntry++;\r\n        if (ntry > 100) {                                      // Max. 100 iterations to obtain random value in [0, p751-1] \r\n            return CRYPTO_ERROR_TOO_MANY_ITERATIONS;\r\n        }\r\n        Status = (pCurveIsogeny->RandomBytesFunction)(nbytes, (unsigned char*)&f2value[1]);\r\n        if (Status != CRYPTO_SUCCESS) {\r\n            return Status;\r\n        }\r\n        ((unsigned char*)&f2value[1])[nbytes-1] &= mask;       // Masking last byte \r\n    } while (mp_sub(p751, f2value[1], t1, NWORDS_FIELD) == 1);\r\n\r\n// Cleanup\r\n    clear_words((void*)t1, NWORDS_FIELD);\r\n\r\n    return CRYPTO_SUCCESS;\r\n}\r\n\r\n\r\nstatic bool test_curve(f2elm_t A, f2elm_t rvalue, PCurveIsogenyStruct CurveIsogeny) \r\n{\r\n    f2elm_t t0, t1, C, one = {0}, zero = {0};\r\n    point_proj_t rP, P1;\r\n    bool valid_curve;\r\n    \r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, one[0]);\r\n\r\n    // Test j invariant in Fp2\\Fp\r\n    fp2sqr751_mont(A, t0);                             // t0 = a^2\r\n    fp2sub751(t0, one, t0);             \r\n    fp2sub751(t0, one, t0);             \r\n    fp2sub751(t0, one, t0);                            // t0 = t0-3\r\n    fp2sqr751_mont(t0, t1);                            // t1 = t0^2\r\n    fp2mul751_mont(t0, t1, t1);                        // t1 = t1*t0\r\n    fp2sub751(t0, one, t0);                            // t0 = t0-1\r\n    fpmul751_mont(t1[0], t0[1], t1[0]);\r\n    fpmul751_mont(t1[1], t0[0], t1[1]);\r\n\r\n    valid_curve = !is_equal_fp(t1[0], t1[1]);\r\n        \r\n    // Test supersingular\r\n    fp2copy751(rvalue, rP->X);\r\n    fp2copy751(one, rP->Z);\r\n    fp2copy751(one, C);\r\n\r\n    xDBLe(rP, rP, A, C, 1);\r\n    xDBLe(rP, P1, A, C, 371);    \r\n    xTPLe(P1, P1, A, C, 239);    \r\n    fp2mul751_mont(rP->X, P1->Z, rP->X);               // X = X*Z1\r\n    fp2mul751_mont(rP->Z, P1->X, rP->Z);               // Z = Z*X1\r\n    fp2sub751(rP->X, rP->Z, rP->X);                    // X = X-Z\r\n    fp2mul751_mont(rP->X, P1->Z, rP->X);               // X = X*Z1\r\n\r\n   return (valid_curve && is_equal_fp2(rP->X, zero));\r\n}\r\n\r\n\r\nstatic void cube_indeterminant(f2elm_t a, f2elm_t b, f2elm_t sq)\r\n{ // Computes a*y+b <-- (a*y+b)^3 where y^2=sq\r\n    f2elm_t t0, t1, t2, t3;\r\n\r\n    fp2copy751(a, t0); \r\n    fp2sqr751_mont(b, t1);    \r\n    fp2sqr751_mont(t0, t2);    \r\n    fp2mul751_mont(sq, t2, t2);    \r\n    fp2add751(t1, t2, t3);        \r\n    fp2add751(t1, t3, a);        \r\n    fp2add751(t1, a, a);        \r\n    fp2mul751_mont(t0, a, a);    \r\n    fp2add751(t2, t3, t1);        \r\n    fp2add751(t2, t1, t1);        \r\n    fp2mul751_mont(b, t1, b);    \r\n}\r\n\r\n\r\nstatic void line_indeterminant_TPL(f2elm_t a, f2elm_t b, f2elm_t c, f2elm_t d, f2elm_t sq)\r\n{ // Computes a*y+b <-- (a*y+b)*(c*y+d) where y^2=sq\r\n    f2elm_t t0, t1;\r\n\r\n    fp2mul751_mont(a, c, t0);   \r\n    fp2mul751_mont(a, d, a);  \r\n    fp2mul751_mont(b, c, t1);  \r\n    fp2add751(a, t1, a); \r\n    fp2mul751_mont(b, d, t1);  \r\n    fp2mul751_mont(t0, sq, b);  \r\n    fp2add751(b, t1, b);  \r\n}\r\n\r\n\r\nstatic void TPLline(point_proj_t P, point_proj_t Q, publickey_t PK, point_proj_t UP, point_proj_t UQ, f2elm_t alpha_numer, f2elm_t beta_numer, f2elm_t alpha_denom, f2elm_t beta_denom)   /// x,z,X,Z,xP,xQ,A \r\n{\r\n    f2elm_t x, z, X, Z;\r\n    f2elm_t t0, t1, t2, t3, t4, t5, t6, l0P, l1P, l2P, l0Q, l1Q, l2Q;\r\n\r\n    fp2copy751(P->X, x);\r\n    fp2copy751(P->Z, z);\r\n    fp2copy751(Q->X, X);\r\n    fp2copy751(Q->Z, Z);\r\n      \r\n    fp2sqr751_mont(x, t0);                             // t0 = x^2\r\n    fp2sqr751_mont(z, t1);                             // t1 = z^2\r\n    fp2mul751_mont(x, z, t2);                          // t2 = x*z\r\n    fp2mul751_mont(PK[0], t2, t3);                     // t3 = A*t2\r\n    fp2add751(t0, t1, t4);                             // t4 = t0+t1\r\n    fp2add751(t3, t4, t5);                             // t5 = t4+t3\r\n    fp2add751(t3, t5, t3);                             // t3 = t3+t5\r\n    fp2add751(t5, t5, t5);                             // t5 = t5+t5\r\n    fp2add751(t1, t1, l2P);                            // l2P = t1+t1\r\n    fp2add751(t1, l2P, l2P);                           // l2P = l2P+t1\r\n    fp2add751(t3, l2P, l2P);                           // l2P = l2P+t3\r\n    fp2add751(t5, l2P, l2P);                           // l2P = l2P+t5\r\n    fp2mul751_mont(t0, l2P, l2P);                      // l2P = l2P*t0\r\n    fp2sqr751_mont(t1, alpha_numer);                   // alpha_numer = t1^2\r\n    fp2sub751(l2P, alpha_numer, l2P);                  // l2P = l2P-alpha_numer\r\n    fp2add751(t0, t3, l1P);                            // l1P = t0+t3\r\n    fp2add751(t0, l1P, l1P);                           // l1P = l1P+t0\r\n    fp2mul751_mont(t5, l1P, l1P);                      // l1P = t5*l1P\r\n    fp2sub751(l1P, l2P, l1P);                          // l1P = l1P-l2P\r\n    fp2add751(l1P, l1P, l1P);                          // l1P = l1P+l1P\r\n    fp2sub751(t0, t1, l0P);                            // l0P = t0-t1\r\n    fp2mul751_mont(t5, l0P, l0P);                      // l0P = l0P*t5\r\n    fp2add751(l0P, l0P, l0P);                          // l0P = l0P+l0P\r\n    fp2sub751(l2P, l0P, l0P);                          // l0P = l2P-l0P\r\n    fp2sqr751_mont(l0P, P->X);                         // X3 = l0P^2\r\n    fp2sqr751_mont(l2P, P->Z);                         // Z3 = l2P^2\r\n    fp2mul751_mont(x, t5, alpha_numer);                // alpha_numer = x*t5\r\n    fp2add751(alpha_numer, alpha_numer, alpha_numer);  // alpha_numer = alpha_numer+alpha_numer\r\n    fp2add751(alpha_numer, alpha_numer, alpha_numer);  // alpha_numer = alpha_numer+alpha_numer\r\n    fp2mul751_mont(t0, l0P, t0);                       // t0 = t0*l0P\r\n    fp2mul751_mont(l2P, PK[2], t5);                    // t5 = l2P*xQ\r\n    fp2mul751_mont(t1, t5, t5);                        // t5 = t5*t1\r\n    fp2mul751_mont(l1P, t2, beta_numer);               // beta_numer = l1P*t2\r\n    fp2add751(t5, beta_numer, beta_numer);             // beta_numer = beta_numer+t5\r\n    fp2mul751_mont(PK[2], beta_numer, beta_numer);     // beta_numer = beta_numer*xQ\r\n    fp2add751(t0, beta_numer, beta_numer);             // beta_numer = beta_numer+t0\r\n    fp2neg751(beta_numer);                             // beta_numer = -beta_numer\r\n    fp2mul751_mont(PK[0], t4, t5);                     // t5 = A*t4\r\n    fp2sqr751_mont(t4, t4);                            // t4 = t4^2\r\n    fp2add751(t2, t2, t2);                             // t2 = t2+t2\r\n    fp2add751(t2, t5, UP->X);                          // UP = t5+t2\r\n    fp2sub751(t5, t2, t5);                             // t5 = t5-t2\r\n    fp2mul751_mont(t2, UP->X, UP->X);                  // UP = t2*UP\r\n    fp2add751(t4, UP->X, UP->X);                       // UP = UP+t4\r\n    fp2mul751_mont(t2, t5, t2);                        // t2 = t2*t5\r\n    fp2add751(t2, t4, t2);                             // t2 = t2+t4\r\n    fp2add751(t4, t4, t4);                             // t4 = t4+t4\r\n    fp2add751(t2, t4, t2);                             // t2 = t2+t4\r\n    fp2mul751_mont(UP->X, t2, UP->X);                  // UP = UP*t2\r\n    fp2add751(UP->X, UP->X, UP->X);                    // UP = UP+UP\r\n    fp2add751(UP->X, UP->X, UP->X);                    // UP = UP+UP\r\n    fp2sub751(UP->X, P->X, UP->X);                     // UP = UP-X3\r\n    fp2mul751_mont(P->X, x, P->X);                     // X3 = x*X3\r\n    fp2sub751(UP->X, P->Z, UP->X);                     // UP = UP-Z3\r\n    fp2neg751(UP->X);                                  // UP = -UP\r\n    fp2mul751_mont(l0P, UP->X, UP->X);                 // UP = UP*l0P\r\n    fp2mul751_mont(P->Z, l2P, UP->Z);                  // UPZ = Z3*l2P\r\n    fp2add751(UP->Z, UP->Z, UP->Z);                    // UPZ = UPZ+UPZ\r\n    fp2mul751_mont(P->Z, z, P->Z);                     // Z3 = z*Z3 \r\n    fp2sqr751_mont(X, t0);                             // t0 = X^2\r\n    fp2sqr751_mont(Z, t6);                             // t6 = Z^2\r\n    fp2mul751_mont(X, Z, t2);                          // t2 = X*Z\r\n    fp2mul751_mont(PK[0], t2, t3);                     // t3 = A*t2\r\n    fp2add751(t0, t6, t4);                             // t4 = t0+t6\r\n    fp2add751(t3, t4, t5);                             // t5 = t4+t3\r\n    fp2add751(t3, t5, t3);                             // t3 = t3+t5\r\n    fp2add751(t5, t5, t5);                             // t5 = t5+t5\r\n    fp2add751(t6, t6, l2Q);                            // l2Q = t6+t6\r\n    fp2add751(t6, l2Q, l2Q);                           // l2Q = l2Q+t6\r\n    fp2add751(t3, l2Q, l2Q);                           // l2Q = l2Q+t3\r\n    fp2add751(t5, l2Q, l2Q);                           // l2Q = l2Q+t5\r\n    fp2mul751_mont(t0, l2Q, l2Q);                      // l2Q = l2Q*t0\r\n    fp2sqr751_mont(t6, alpha_denom);                   // alpha_denom = t6^2\r\n    fp2sub751(l2Q, alpha_denom, l2Q);                  // l2Q = l2Q-alpha_denom\r\n    fp2add751(t0, t3, l1Q);                            // l1Q = t0+t3\r\n    fp2add751(t0, l1Q, l1Q);                           // l1Q = l1Q+t0\r\n    fp2mul751_mont(t5, l1Q, l1Q);                      // l1Q = t5*l1Q\r\n    fp2sub751(l1Q, l2Q, l1Q);                          // l1Q = l1Q-l2Q\r\n    fp2add751(l1Q, l1Q, l1Q);                          // l1Q = l1Q+l1Q\r\n    fp2sub751(t0, t6, l0Q);                            // l0Q = t0-t6\r\n    fp2mul751_mont(t5, l0Q, l0Q);                      // l0Q = l0Q*t5\r\n    fp2add751(l0Q, l0Q, l0Q);                          // l0Q = l0Q+l0Q\r\n    fp2sub751(l2Q, l0Q, l0Q);                          // l0Q = l2Q-l0Q\r\n    fp2sqr751_mont(l0Q, Q->X);                         // X4 = l0Q^2\r\n    fp2sqr751_mont(l2Q, Q->Z);                         // Z4 = l2Q^2\r\n    fp2mul751_mont(X, t5, alpha_denom);                // alpha_denom = X*t5\r\n    fp2add751(alpha_denom, alpha_denom, alpha_denom);  // alpha_denom = alpha_denom+alpha_denom\r\n    fp2add751(alpha_denom, alpha_denom, alpha_denom);  // alpha_denom = alpha_denom+alpha_denom\r\n    fp2mul751_mont(t0, l0Q, t0);                       // t0 = t0*l0Q\r\n    fp2mul751_mont(l2Q, PK[1], t5);                    // t5 = l2Q*xP\r\n    fp2mul751_mont(t6, t5, t5);                        // t5 = t5*t6\r\n    fp2mul751_mont(l1Q, t2, beta_denom);               // beta_denom = l1Q*t2\r\n    fp2add751(t5, beta_denom, beta_denom);             // beta_denom = beta_denom+t5\r\n    fp2mul751_mont(PK[1], beta_denom, beta_denom);     // beta_denom = beta_denom*xP\r\n    fp2add751(t0, beta_denom, beta_denom);             // beta_denom = beta_denom+t0\r\n    fp2neg751(beta_denom);                             // beta_denom = -beta_denom\r\n    fp2mul751_mont(PK[0], t4, t5);                     // t5 = A*t4\r\n    fp2sqr751_mont(t4, t4);                            // t4 = t4^2\r\n    fp2add751(t2, t2, t2);                             // t2 = t2+t2\r\n    fp2add751(t5, t2, UQ->X);                          // UQ = t5+t2\r\n    fp2sub751(t5, t2, t5);                             // t5 = t5-t2\r\n    fp2mul751_mont(UQ->X, t2, UQ->X);                  // UQ = t2*UQ\r\n    fp2add751(UQ->X, t4, UQ->X);                       // UQ = UQ+t4\r\n    fp2mul751_mont(t2, t5, t2);                        // t2 = t2*t5\r\n    fp2add751(t4, t2, t2);                             // t2 = t2+t4\r\n    fp2add751(t4, t4, t4);                             // t4 = t4+t4\r\n    fp2add751(t2, t4, t2);                             // t2 = t2+t4\r\n    fp2mul751_mont(UQ->X, t2, UQ->X);                  // UQ = UQ*t2\r\n    fp2add751(UQ->X, UQ->X, UQ->X);                    // UQ = UQ+UQ\r\n    fp2add751(UQ->X, UQ->X, UQ->X);                    // UQ = UQ+UQ\r\n    fp2sub751(UQ->X, Q->X, UQ->X);                     // UQ = UQ-X4\r\n    fp2mul751_mont(Q->X, X, Q->X);                     // X4 = X*X4\r\n    fp2sub751(UQ->X, Q->Z, UQ->X);                     // UQ = UQ-Z4\r\n    fp2neg751(UQ->X);                                  // UQ = -UQ\r\n    fp2mul751_mont(l0Q, UQ->X, UQ->X);                 // UQ = UQ*l0Q\r\n    fp2mul751_mont(Q->Z, l2Q, UQ->Z);                  // UQZ = Z4*l2Q\r\n    fp2add751(UQ->Z, UQ->Z, UQ->Z);                    // UQZ = UQZ+UQZ\r\n    fp2mul751_mont(Q->Z, Z, Q->Z);                     // Z4 = Z*Z4 \r\n    fp2mul751_mont(t1, t6, t2);                        // t2:=t1*t6;\r\n    fp2mul751_mont(t6, P->Z, t6);                      // t6:=t6*Z3;\r\n    fp2mul751_mont(t1, Q->Z, t1);                      // t1:=t1*Z4;\r\n    fp2mul751_mont(alpha_denom, Z, alpha_denom);       // alpha_denom:=alpha_denom*Z;\r\n    fp2mul751_mont(alpha_denom, Q->Z, alpha_denom);    // alpha_denom:=alpha_denom*Z4;\r\n    fp2mul751_mont(alpha_numer, z, alpha_numer);       // alpha_numer:=alpha_numer*z;\r\n    fp2mul751_mont(alpha_numer, P->Z, alpha_numer);    // alpha_numer:=alpha_numer*Z3;\r\n    fp2mul751_mont(PK[1], Q->Z, t3);                   // t3:=xP*Z4;\r\n    fp2sub751(t3, Q->X, t3);                           // t3:=t3-X4;\r\n    fp2mul751_mont(t3, l2Q, t3);                       // t3:=t3*l2Q;\r\n    fp2mul751_mont(PK[2], P->Z, t5);                   // t5:=xQ*Z3;\r\n    fp2sub751(t5, P->X, t5);                           // t5:=t5-X3;\r\n    fp2mul751_mont(t5, l2P, t5);                       // t5:=t5*l2P;\r\n    fp2mul751_mont(alpha_numer, t3, alpha_numer);      // alpha_numer:=alpha_numer*t3;\r\n    fp2mul751_mont(t2, alpha_numer, alpha_numer);      // alpha_numer:=alpha_numer*t2;\r\n    fp2mul751_mont(beta_numer, t3, beta_numer);        // beta_numer:=beta_numer*t3;\r\n    fp2mul751_mont(t6, beta_numer, beta_numer);        // beta_numer:=beta_numer*t6;\r\n    fp2mul751_mont(alpha_denom, t5, alpha_denom);      // alpha_denom:=alpha_denom*t5;\r\n    fp2mul751_mont(t2, alpha_denom, alpha_denom);      // alpha_denom:=alpha_denom*t2;\r\n    fp2mul751_mont(beta_denom, t5, beta_denom);        // beta_denom:=beta_denom*t5;\r\n    fp2mul751_mont(t1, beta_denom, beta_denom);        // beta_denom:=beta_denom*t1;\r\n}\r\n\r\n\r\nCRYPTO_STATUS Validate_PKA(unsigned char* pPublicKeyA, bool* valid, PCurveIsogenyStruct CurveIsogeny)\r\n{ // Bob validating Alice's public key\r\n  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().\r\n    f2elm_t PKA[4];\r\n    f2elm_t t0, t1, t2, t3, t4, t5, t6, t7, lambdaP, lambdaQ, lnQ, lnP, ldQ, ldP, uP = {0}, uQ = {0}, uPD = {0}, uQD = {0}, sqP, sqQ, sq;\r\n    f2elm_t rvalue, alphan, betan, alphad, betad, alpha_numer = {0}, alpha_denom = {0}, beta_numer = {0}, beta_denom = {0}, one = {0}, zero = {0};\r\n    point_proj_t P = {0}, Q = {0}, UP, UQ; \r\n    unsigned int j, e = CurveIsogeny->eB; \r\n    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN;\r\n\r\n    // Choose a random element in GF(p751^2), assume that it is in Montgomery representation\r\n    Status = random_fp2(rvalue, CurveIsogeny);    \r\n    if (Status != CRYPTO_SUCCESS) {\r\n        clear_words((void*)rvalue, 2*NWORDS_FIELD);\r\n        return Status;\r\n    }\r\n                      \r\n    to_fp2mont(((f2elm_t*)pPublicKeyA)[0], PKA[0]);    // Conversion of Alice's public key to Montgomery representation\r\n    to_fp2mont(((f2elm_t*)pPublicKeyA)[1], PKA[1]);\r\n    to_fp2mont(((f2elm_t*)pPublicKeyA)[2], PKA[2]);\r\n    to_fp2mont(((f2elm_t*)pPublicKeyA)[3], PKA[3]);\r\n\r\n    fp2copy751(PKA[1], P->X);\r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, P->Z[0]);\r\n    fp2copy751(PKA[2], Q->X);\r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, Q->Z[0]);\r\n    \r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, one[0]);\r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, uP[0]);\r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, uQ[0]);\r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, uPD[0]);\r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, uQD[0]);\r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, beta_numer[0]);\r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, beta_denom[0]);\r\n\r\n    fp2add751(PKA[0], PKA[1], sqP);                    // sqP = xP+A\r\n    fp2mul751_mont(PKA[1], sqP, sqP);                  // sqP = xP*sqP\r\n    fp2add751(one, sqP, sqP);                          // sqP = sqP+1\r\n    fp2add751(PKA[0], PKA[2], sqQ);                    // sqQ = xQ+A\r\n    fp2mul751_mont(PKA[2], sqQ, sqQ);                  // sqQ = xQ*sqQ\r\n    fp2add751(one, sqQ, sqQ);                          // sqQ = sqQ+1\r\n    fp2mul751_mont(PKA[2], sqQ, sqQ);                  // sqQ = xQ*sqQ\r\n    fp2mul751_mont(PKA[1], sqP, sqP);                  // sqP = xP*sqP\r\n    fp2mul751_mont(sqQ, sqP, sq);                      // sq = sqP*sqQ\r\n\r\n    for (j = 1; j < e; j++) {\r\n        cube_indeterminant(alpha_numer, beta_numer, sq);\r\n        cube_indeterminant(alpha_denom, beta_denom, sq);\r\n        TPLline(P, Q, PKA, UP, UQ, alphan, betan, alphad, betad);\r\n\r\n        fp2mul751_mont(uP, alphan, alphan);            // alphan = alphan*uP\r\n        fp2mul751_mont(uQD, alphan, alphan);           // alphan = alphan*uQD \r\n        fp2mul751_mont(uQ, alphad, alphad);            // alphad = alphad*uQ \r\n        fp2mul751_mont(uPD, alphad, alphad);           // alphad = alphad*uPD\r\n        fp2mul751_mont(uQD, uPD, t0);                  // t0 = uQD*uPD\r\n        fp2mul751_mont(betan, t0, betan);              // betan = betan*t0\r\n        fp2mul751_mont(betad, t0, betad);              // betad = betad*t0\r\n        fp2mul751_mont(uP, UP->X, uP);                 // uP = uP*UP\r\n        fp2mul751_mont(uPD, UP->Z, uPD);               // uPD = uPD*UPZ\r\n        fp2mul751_mont(uQ, UQ->X, uQ);                 // uQ = uQ*UQ\r\n        fp2mul751_mont(uQD, UQ->Z, uQD);               // uQD = uQD*UQZ\r\n\r\n        line_indeterminant_TPL(alpha_numer, beta_numer, alphan, betan, sq);\r\n        line_indeterminant_TPL(alpha_denom, beta_denom, alphad, betad, sq);\r\n    }\r\n\r\n    cube_indeterminant(alpha_numer, beta_numer, sq);\r\n    cube_indeterminant(alpha_denom, beta_denom, sq);\r\n    \r\n    fp2mul751_mont(PKA[0], P->Z, t0);                  // t0 = A*ZP\r\n    fp2add751(P->X, P->X, t1);                         // t1 = XP+XP\r\n    fp2add751(P->X, t1, t1);                           // t1 = t1+XP\r\n    fp2add751(t0, t1, t2);                             // t2 = t1+t0\r\n    fp2add751(t0, t2, t1);                             // t1 = t2+t0\r\n    fp2mul751_mont(P->X, t1, lambdaP);                 // lambdaP = t1*XP\r\n    fp2sqr751_mont(P->Z, t1);                          // t1 = ZP^2\r\n    fp2add751(lambdaP, t1, lambdaP);                   // lambdaP = lambdaP+t1\r\n    fp2mul751_mont(t1, P->Z, t1);                      // t1 = t1*ZP\r\n    fp2mul751_mont(sqP, t1, t0);                       // t0 = t1*sqP\r\n    fp2mul751_mont(t1, uPD, t1);                       // t1 = t1*uPD\r\n    fp2sqr751_mont(uP, t3);                            // t3 = uP^2\r\n    fp2mul751_mont(t0, t3, t0);                        // t0 = t0*t3\r\n    fp2add751(t0, t0, t0);                             // t0 = t0+t0\r\n    fp2mul751_mont(t2, t0, t2);                        // t2 = t2*t0\r\n    fp2add751(t2, t2, t2);                             // t2 = t2+t2\r\n    fp2mul751_mont(lambdaP, uPD, t3);                  // t3 = lambdaP*uPD\r\n    fp2sqr751_mont(t3, t4);                            // t4 = t3^2\r\n\r\n    *valid = is_equal_fp2(t2, t4);                     // Checks order P by\r\n    *valid = *valid & !is_equal_fp2(t2, zero);         // asserting that 3^238*P has order 3\r\n        \r\n    fp2mul751_mont(PKA[0], Q->Z, t5);                  // t5 = A*ZQ\r\n    fp2add751(Q->X, Q->X, t6);                         // t6 = XQ+XQ\r\n    fp2add751(Q->X, t6, t6);                           // t6 = t6+XQ\r\n    fp2add751(t5, t6, t2);                             // t2 = t6+t5\r\n    fp2add751(t2, t5, t6);                             // t6 = t2+t5\r\n    fp2mul751_mont(Q->X, t6, lambdaQ);                 // lambdaQ = t6*XQ\r\n    fp2sqr751_mont(Q->Z, t6);                          // t6 = ZQ^2\r\n    fp2add751(lambdaQ, t6, lambdaQ);                   // lambdaQ = lambdaQ+t6\r\n    fp2mul751_mont(Q->Z, t6, t6);                      // t6 = t6*ZQ\r\n    fp2mul751_mont(sqQ, t6, t5);                       // t5 = t6*sqQ\r\n    fp2mul751_mont(t6, uQD, t6);                       // t6 = t6*uQD\r\n    fp2sqr751_mont(uQ, t7);                            // t7 = uQ^2\r\n    fp2mul751_mont(t5, t7, t5);                        // t5 = t5*t7\r\n    fp2add751(t5, t5, t5);                             // t5 = t5+t5\r\n    fp2mul751_mont(t2, t5, t2);                        // t2 = t2*t5\r\n    fp2add751(t2, t2, t2);                             // t2 = t2+t2\r\n    fp2mul751_mont(lambdaQ, uQD, t7);                  // t7 = lambdaQ*uQD\r\n    fp2sqr751_mont(t7, t4);                            // t4 = t7^2\r\n\r\n    *valid = *valid & is_equal_fp2(t2, t4);            // Checks order Q by\r\n    *valid = *valid & !is_equal_fp2(t2, zero);         // asserting that 3^238*Q has order 3\r\n\r\n    fp2mul751_mont(PKA[2], P->Z, lnQ);                 // lnQ = xQ*ZP\r\n    fp2sub751(P->X, lnQ, lnQ);                         // lnQ = XP-lnQ\r\n    fp2mul751_mont(t3, lnQ, lnQ);                      // lnQ = t3*lnQ\r\n    fp2mul751_mont(uPD, lnQ, lnQ);                     // lnQ = lnQ*uPD\r\n    fp2sub751(lnQ, t0, lnQ);                           // lnQ = lnQ-t0\r\n    fp2mul751_mont(PKA[1], Q->Z, ldP);                 // ldP = xP*ZQ\r\n    fp2sub751(Q->X, ldP, ldP);                         // ldP = XQ-ldP\r\n    fp2mul751_mont(t7, ldP, ldP);                      // ldP = t7*ldP\r\n    fp2mul751_mont(uQD, ldP, ldP);                     // ldP = uQD*ldP\r\n    fp2sub751(ldP, t5, ldP);                           // ldP = ldP-t5\r\n    fp2mul751_mont(uP, uQ, lnP);                       // lnP = uP*uQ\r\n    fp2add751(lnP, lnP, lnP);                          // lnP = lnP+lnP\r\n    fp2mul751_mont(sqP, lnP, ldQ);                     // ldQ = lnP*sqP\r\n    fp2mul751_mont(lnP, sqQ, lnP);                     // lnP = lnP*sqQ\r\n    fp2mul751_mont(ldP, uP, ldP);                      // ldP = ldP*uP\r\n    fp2mul751_mont(t1, ldP, ldP);                      // ldP = ldP*t1\r\n    fp2mul751_mont(lnQ, uQ, lnQ);                      // lnQ = lnQ*uQ\r\n    fp2mul751_mont(t6, lnQ, lnQ);                      // lnQ = lnQ*t6\r\n    fp2mul751_mont(t1, t6, t1);                        // t1 = t1*t6\r\n    fp2mul751_mont(lnP, t1, lnP);                      // lnP = lnP*t1    \r\n    fp2mul751_mont(ldQ, t1, ldQ);                      // ldQ = ldQ*t1\r\n    fp2copy751(alpha_numer, t0);                       // t0 = alpha_numer\r\n    fp2mul751_mont(lnP, t0, alpha_numer);              // alpha_numer = lnP*t0\r\n    fp2mul751_mont(sqP, alpha_numer, alpha_numer);     // alpha_numer = alpha_numer*sqP\r\n    fp2mul751_mont(lnQ, beta_numer, t1);               // t1 = lnQ*beta_numer\r\n    fp2add751(alpha_numer, t1, alpha_numer);           // alpha_numer = t1+alpha_numer\r\n    fp2mul751_mont(t0, sqQ, t1);                       // t1 = t0*sqQ\r\n    fp2mul751_mont(t1, lnQ, t1);                       // t1 = t1*lnQ\r\n    fp2mul751_mont(lnP, beta_numer, beta_numer);       // beta_numer = lnP*beta_numer\r\n    fp2add751(t1, beta_numer, beta_numer);             // beta_numer = beta_numer+t1\r\n    fp2copy751(alpha_denom, t0);                       // t0 = alpha_denom\r\n    fp2mul751_mont(ldP, t0, t1);                       // t1 = ldP*t0\r\n    fp2mul751_mont(sqP, t1, t1);                       // t1 = t1*sqP\r\n    fp2mul751_mont(beta_denom, ldQ, alpha_denom);      // alpha_denom = ldQ*beta_denom\r\n    fp2add751(t1, alpha_denom, alpha_denom);           // alpha_denom = alpha_denom+t1\r\n    fp2mul751_mont(t0, sqQ, t1);                       // t1 = t0*sqQ\r\n    fp2mul751_mont(ldQ, t1, t1);                       // t1 = ldQ*t1\r\n    fp2mul751_mont(beta_denom, ldP, beta_denom);       // beta_denom = ldP*beta_denom\r\n    fp2add751(t1, beta_denom, beta_denom);             // beta_denom = beta_denom+t1    \r\n    fp2add751(alpha_numer, alpha_denom, t2);           // t2 = alpha_numer+alpha_denom\r\n    fp2sqr751_mont(t2, t2);                            // t2 = t2^2\r\n    fp2mul751_mont(sqQ, t2, t2);                       // t2 = t2*sqQ\r\n    fp2add751(beta_numer, beta_denom, t4);             // t4 = beta_numer+beta_denom\r\n    fp2sqr751_mont(t4, t4);                            // t4 = t4^2\r\n    fp2mul751_mont(sqP, t4, t4);                       // t4 = t4*sqP\r\n    \r\n    *valid = *valid & !is_equal_fp2(t2, t4);           // iff weil pairing != 1\r\n\r\n    fp2add751(PKA[1], PKA[2], t0);                     // t0 = xP+xQ\r\n    fp2mul751_mont(PKA[3], t0, t1);                    // t1 = xQP*t0\r\n    fp2sub751(t1, one, t1);                            // t1 = t1-1\r\n    fp2mul751_mont(PKA[1], PKA[2], t2);                // t2 = xP*xQ\r\n    fp2add751(t1, t2, t1);                             // t1 = t2+t1\r\n    fp2sqr751_mont(t1, t1);                            // t1 = t1^2\r\n    fp2add751(t0, PKA[3], t0);                         // t0 = t0+xQP\r\n    fp2add751(PKA[0], t0, t0);                         // t0 = t0+A\r\n    fp2mul751_mont(t2, PKA[3], t2);                    // t2 = t2*xQP\r\n    fp2mul751_mont(t0, t2, t0);                        // t0 = t0*t2\r\n    fp2add751(t0, t0, t0);                             // t0 = t0+t0\r\n    fp2add751(t0, t0, t0);                             // t0 = t0+t0\r\n    \r\n    *valid = *valid & is_equal_fp2(t0, t1);            // Third point is difference\r\n    *valid = *valid & test_curve(PKA[0], rvalue, CurveIsogeny); \r\n\r\n    return CRYPTO_SUCCESS;\r\n}\r\n\r\n\r\nCRYPTO_STATUS Validate_PKB(unsigned char* pPublicKeyB, bool* valid, PCurveIsogenyStruct CurveIsogeny)\r\n{ // Bob validating Alice's public key\r\n  // CurveIsogeny must be set up in advance using SIDH_curve_initialize().\r\n    f2elm_t PKB[4];\r\n    f2elm_t t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, fP = {0}, fQ = {0}, UP = {0}, UQ = {0}, VP = {0}, VQ = {0};\r\n    f2elm_t rvalue, cP, cQ, alphaQi, betaPi, alphaPi, betaQi, alphaP = {0}, alphaQ = {0}, betaP = {0}, betaQ = {0}, one = {0}, zero = {0};\r\n    point_proj_t P = {0}, Q = {0}; \r\n    unsigned int i, e = CurveIsogeny->oAbits; \r\n    CRYPTO_STATUS Status = CRYPTO_ERROR_UNKNOWN; \r\n\r\n    // Choose a random element in GF(p751^2), assume that it is in Montgomery representation\r\n    Status = random_fp2(rvalue, CurveIsogeny);    \r\n    if (Status != CRYPTO_SUCCESS) {\r\n        clear_words((void*)rvalue, 2*NWORDS_FIELD);\r\n        return Status;\r\n    }\r\n                      \r\n    to_fp2mont(((f2elm_t*)pPublicKeyB)[0], PKB[0]);    // Conversion of Bob's public key to Montgomery representation\r\n    to_fp2mont(((f2elm_t*)pPublicKeyB)[1], PKB[1]);\r\n    to_fp2mont(((f2elm_t*)pPublicKeyB)[2], PKB[2]);\r\n    to_fp2mont(((f2elm_t*)pPublicKeyB)[3], PKB[3]);\r\n\r\n    fp2copy751(PKB[1], P->X);\r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, P->Z[0]);\r\n    fp2copy751(PKB[2], Q->X);\r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, Q->Z[0]);\r\n    fp2copy751(PKB[1], t0);\r\n    fp2copy751(PKB[2], t1);\r\n    \r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, one[0]);\r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, fP[0]);\r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, fQ[0]);\r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, UP[0]);\r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, UQ[0]);\r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, VP[0]);\r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, VQ[0]);\r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, betaP[0]);\r\n    fpcopy751((digit_t*)CurveIsogeny->Montgomery_one, betaQ[0]);\r\n    \r\n    fp2add751(PKB[0], PKB[2], cQ);                     // cQ = xQ+A\r\n    fp2add751(PKB[0], PKB[1], cP);                     // cP = xP+A\r\n    fp2mul751_mont(cQ, PKB[2], cQ);                    // cQ = cQ*xQ \r\n    fp2mul751_mont(cP, PKB[1], cP);                    // cP = cP*xP \r\n    fp2add751(cQ, one, cQ);                            // cQ = cQ+1\r\n    fp2add751(cP, one, cP);                            // cP = cP+1\r\n    fp2mul751_mont(cQ, PKB[2], cQ);                    // cQ = cQ*xQ\r\n    fp2mul751_mont(cP, PKB[1], cP);                    // cP = cP*xP\r\n\r\n    for (i = 1; i < e; i++) {             \r\n        fp2sqr751_mont(P->X, t2);                      // t2 = XP^2\r\n        fp2sqr751_mont(P->Z, t11);                     // t11 = ZP^2\r\n        fp2sqr751_mont(Q->X, t4);                      // t4 = XQ^2\r\n        fp2sqr751_mont(Q->Z, t10);                     // t10 = ZQ^2\r\n        fp2sub751(t2, t11, t6);                        // t6 = t2-t11\r\n        fp2add751(t2, t2, betaPi);                     // betaPi = t2+t2\r\n        fp2add751(t2, t11, t2);                        // t2 = t2+t11\r\n        fp2sub751(t4, t10, t7);                        // t7 = t4-t10\r\n        fp2add751(t4, t4, alphaQi);                    // alphaQi = t4+t4\r\n        fp2add751(t4, t10, t4);                        // t4 = t4+t10\r\n        fp2mul751_mont(P->X, P->Z, t3);                // t3 = XP*ZP \r\n        fp2mul751_mont(Q->X, Q->Z, t5);                // t5 = XQ*ZQ \r\n        fp2mul751_mont(PKB[0], t3, t8);                // t8 = A*t3\r\n        fp2mul751_mont(PKB[0], t5, t9);                // t9 = A*t5\r\n        fp2add751(t3, t3, t3);                         // t3 = t3+t3\r\n        fp2add751(t5, t5, t5);                         // t5 = t5+t5\r\n        fp2add751(betaPi, t8, betaPi);                 // betaPi = betaPi+t8\r\n        fp2add751(t2, t8, t8);                         // t8 = t8+t2\r\n        fp2add751(alphaQi, t9, alphaQi);               // alphaQi = alphaQi+t9\r\n        fp2add751(t4, t9, t9);                         // t9 = t9+t4\r\n        fp2mul751_mont(PKB[0], t2, t2);                // t2 = A*t2\r\n        fp2mul751_mont(PKB[0], t4, t4);                // t4 = A*t4\r\n        fp2add751(betaPi, t8, betaPi);                 // betaPi = betaPi+t8\r\n        fp2add751(alphaQi, t9, alphaQi);               // alphaQi = alphaQi+t9\r\n        fp2mul751_mont(betaPi, t1, betaPi);            // betaPi = betaPi*t1\r\n        fp2mul751_mont(alphaQi, t0, alphaQi);          // alphaQi = alphaQi*t0\r\n        fp2mul751_mont(P->X, t6, t1);                  // t1 = XP*t6\r\n        fp2mul751_mont(Q->X, t7, t0);                  // t0 = XQ*t7\r\n        fp2sub751(t1, betaPi, t1);                     // t1 = t1-betaPi\r\n        fp2sub751(t0, alphaQi, t0);                    // t0 = t0-alphaQi\r\n        fp2mul751_mont(VP, t1, betaPi);                // betaPi = VP*t1\r\n        fp2mul751_mont(VQ, t0, alphaQi);               // alphaQi = VQ*t0\r\n        fp2mul751_mont(Q->Z, t10, t10);                // t10 = t10*ZQ\r\n        fp2mul751_mont(P->Z, t11, t11);                // t11 = t11*ZP\r\n        fp2mul751_mont(t10, UQ, t10);                  // t10 = t10*UQ\r\n        fp2mul751_mont(t11, UP, t11);                  // t11 = t11*UP\r\n        fp2mul751_mont(betaPi, t10, betaPi);           // betaPi = betaPi*t10\r\n        fp2mul751_mont(alphaQi, t11, alphaQi);         // alphaQi = alphaQi*t11\r\n        fp2mul751_mont(t10, t11, t10);                 // t10 = t10*t11\r\n        fp2add751(t10, t10, t10);                      // t10 = t10+t10\r\n        fp2mul751_mont(cQ, t10, alphaPi);              // alphaPi = cQ*t10\r\n        fp2mul751_mont(cP, t10, betaQi);               // betaQi = cP*t10\r\n        fp2mul751_mont(UQ, t7, UQ);                    // UQ = UQ*t7\r\n        fp2mul751_mont(UP, t6, UP);                    // UP = UP*t6\r\n        fp2add751(t8, t8, t8);                         // t8 = t8+t8\r\n        fp2add751(t9, t9, t9);                         // t9 = t9+t9\r\n        fp2mul751_mont(t3, t8, P->Z);                  // ZP = t3*t8\r\n        fp2mul751_mont(t5, t9, Q->Z);                  // ZQ = t5*t9\r\n        fp2mul751_mont(t8, P->X, t8);                  // t8 = t8*XP\r\n        fp2mul751_mont(t9, Q->X, t9);                  // t9 = t9*XQ\r\n        fp2sqr751_mont(t6, P->X);                      // XP = t6^2\r\n        fp2sqr751_mont(t7, Q->X);                      // XQ = t7^2\r\n        fp2add751(t4, t5, t4);                         // t4 = t4+t5\r\n        fp2add751(t5, t4, t4);                         // t4 = t4+t5\r\n        fp2add751(t2, t3, t2);                         // t2 = t2+t3\r\n        fp2add751(t3, t2, t2);                         // t2 = t2+t3\r\n        fp2mul751_mont(t4, t5, t4);                    // t4 = t4*t5\r\n        fp2mul751_mont(t2, t3, t2);                    // t2 = t2*t3\r\n        fp2add751(t4, Q->X, t4);                       // t4 = t4+XQ\r\n        fp2add751(t2, P->X, t2);                       // t2 = t2+XP\r\n        fp2mul751_mont(UQ, t4, UQ);                    // UQ = UQ*t4\r\n        fp2mul751_mont(UP, t2, UP);                    // UP = UP*t2\r\n        fp2sqr751_mont(t9, t9);                        // t9 = t9^2\r\n        fp2sqr751_mont(t8, t8);                        // t8 = t8^2\r\n        fp2mul751_mont(VQ, t9, VQ);                    // VQ = VQ*t9\r\n        fp2mul751_mont(VP, t8, VP);                    // VP = VP*t8\r\n        fp2add751(VQ, VQ, VQ);                         // VQ = VQ+VQ\r\n        fp2add751(VP, VP, VP);                         // VP = VP+VP\r\n        fp2sqr751_mont(alphaP, t4);                    // t4 = alphaP^2\r\n        fp2sqr751_mont(betaP, t5);                     // t5 = betaP^2\r\n        fp2mul751_mont(alphaP, betaP, t6);             // t6 = alphaP*betaP\r\n        fp2add751(t6, t6, t6);                         // t6 = t6+t6 \r\n        fp2mul751_mont(t4, cP, t4);                    // t4 = t4*cP\r\n        fp2mul751_mont(t5, cQ, t5);                    // t5 = t5*cQ\r\n        fp2add751(t4, t5, t4);                         // t4 = t4+t5\r\n        fp2mul751_mont(alphaPi, t4, alphaP);           // alphaP = alphaPi*t4\r\n        fp2mul751_mont(betaPi, t4, betaP);             // betaP = betaPi*t4\r\n        fp2mul751_mont(betaPi, t6, t4);                // t4 = t6*betaPi\r\n        fp2mul751_mont(t4, cQ, t4);                    // t4 = t4*cQ\r\n        fp2mul751_mont(t6, alphaPi, t6);               // t6 = t6*alphaPi\r\n        fp2mul751_mont(cP, t6, t6);                    // t6 = t6*cP\r\n        fp2add751(alphaP, t4, alphaP);                 // alphaP = alphaP+t4\r\n        fp2add751(betaP, t6, betaP);                   // betaP = betaP+t6\r\n        fp2sqr751_mont(alphaQ, t4);                    // t4 = alphaQ^2\r\n        fp2sqr751_mont(betaQ, t5);                     // t5 = betaQ^2\r\n        fp2mul751_mont(alphaQ, betaQ, t6);             // t6 = alphaQ*betaQ\r\n        fp2add751(t6, t6, t6);                         // t6 = t6+t6\r\n        fp2mul751_mont(t4, cP, t4);                    // t4 = t4*cP\r\n        fp2mul751_mont(t5, cQ, t5);                    // t5 = t5*cQ\r\n        fp2add751(t4, t5, t4);                         // t4 = t4+t5\r\n        fp2mul751_mont(alphaQi, t4, alphaQ);           // alphaQ = alphaQi*t4\r\n        fp2mul751_mont(betaQi, t4, betaQ);             // betaQ = betaQi*t4\r\n        fp2mul751_mont(betaPi, t6, t4);                // t4 = t6*betaPi\r\n        fp2mul751_mont(cQ, t4, t4);                    // t4 = t4*cQ\r\n        fp2mul751_mont(t6, betaQi, t5);                // t5 = t6*betaQi\r\n        fp2mul751_mont(t5, cQ, t5);                    // t5 = t5*cQ\r\n        fp2add751(alphaQ, t5, alphaQ);                 // alphaQ = alphaQ+t5\r\n        fp2mul751_mont(t6, alphaQi, t5);               // t5 = t6*alphaQi\r\n        fp2mul751_mont(cP, t5, t5);                    // t5 = t5*cP\r\n        fp2add751(betaQ, t5, betaQ);                   // betaQ = betaQ+t5\r\n        fp2mul751_mont(PKB[1], Q->Z, t0);              // t0 = xP*ZQ \r\n        fp2mul751_mont(PKB[2], P->Z, t1);              // t1 = xQ*ZP \r\n        fp2sub751(Q->X, t0, t2);                       // t2 = XQ-t0\r\n        fp2sub751(P->X, t1, t3);                       // t3 = XP-t1\r\n        fp2mul751_mont(t2, P->Z, t2);                  // t2 = t2*ZP\r\n        fp2mul751_mont(t3, Q->Z, t3);                  // t3 = t3*ZQ\r\n        fp2mul751_mont(alphaP, t2, alphaP);            // alphaP = alphaP*t2\r\n        fp2mul751_mont(betaP, t2, betaP);              // betaP = betaP*t2\r\n        fp2mul751_mont(alphaQ, t3, alphaQ);            // alphaQ = alphaQ*t3\r\n        fp2mul751_mont(betaQ, t3, betaQ);              // betaQ = betaQ*t3\r\n    }\r\n\r\n    fp2mul751_mont(PKB[2], P->Z, t2);                  // t2 = xQ*ZP\r\n    fp2mul751_mont(PKB[1], Q->Z, t3);                  // t3 = xP*ZQ\r\n    fp2sub751(P->X, t2, t2);                           // t2 = XP-t2\r\n    fp2sub751(Q->X, t3, t3);                           // t3 = XQ-t3\r\n    fp2mul751_mont(t2, Q->Z, t2);                      // t2 = t2*ZQ\r\n    fp2mul751_mont(t3, P->Z, t3);                      // t3 = t3*ZP\r\n    fp2sqr751_mont(alphaP, t4);                        // t4 = alphaP^2\r\n    fp2sqr751_mont(betaP, t5);                         // t5 = betaP^2\r\n    fp2mul751_mont(alphaP, betaP, t6);                 // t6 = alphaP*betaP\r\n    fp2add751(t6, t6, t6);                             // t6 = t6+t6\r\n    fp2sqr751_mont(alphaQ, t7);                        // t7 = alphaQ^2\r\n    fp2sqr751_mont(betaQ, t8);                         // t8 = betaQ^2\r\n    fp2mul751_mont(alphaQ, betaQ, t9);                 // t9 = alphaQ*betaQ\r\n    fp2add751(t9, t9, t9);                             // t9 = t9+t9\r\n    fp2mul751_mont(t4, cP, t4);                        // t4 = t4*cP\r\n    fp2mul751_mont(t5, cQ, t5);                        // t5 = t5*cQ\r\n    fp2mul751_mont(t7, cP, t7);                        // t7 = t7*cP\r\n    fp2mul751_mont(t8, cQ, t8);                        // t8 = t8*cQ\r\n    fp2add751(t4, t5, t4);                             // t4 = t4+t5\r\n    fp2add751(t7, t8, t7);                             // t7 = t7+t8\r\n    fp2mul751_mont(t2, t4, t4);                        // t4 = t2*t4\r\n    fp2mul751_mont(t3, t7, t7);                        // t7 = t3*t7\r\n    fp2sub751(t4, t7, t7);                             // t7 = t4-t7\r\n    fp2sqr751_mont(t7, t7);                            // t7 = t7^2\r\n    fp2mul751_mont(t3, t9, t3);                        // t3 = t3*t9\r\n    fp2mul751_mont(t2, t6, t2);                        // t2 = t2*t6\r\n    fp2sub751(t3, t2, t3);                             // t3 = t3-t2\r\n    fp2sqr751_mont(t3, t3);                            // t3 = t3^2\r\n    fp2mul751_mont(cP, t3, t3);                        // t3 = t3*cP\r\n    fp2mul751_mont(cQ, t3, t3);                        // t3 = t3*cQ\r\n    fp2add751(one, one, t10);                          \r\n    fp2add751(t10, t10, t11);                          // t11 = 4\r\n    fp2add751(t10, PKB[0], t10);                       // t10 = A+2\r\n    \r\n    *valid = !is_equal_fp2(Q->Z, zero);                // Checks order Q\r\n    xDBL(Q, Q, t10, t11);                              // xDBL(XQ,ZQ,A+2,4);    \r\n    *valid = *valid & is_equal_fp2(Q->Z, zero);  \r\n    \r\n    *valid = *valid & !is_equal_fp2(P->Z, zero);       // Checks order P\r\n    xDBL(P, P, t10, t11);                              // xDBL(XP,ZP,A+2,4); \r\n    *valid = *valid & is_equal_fp2(P->Z, zero);  \r\n    *valid = *valid & !is_equal_fp2(t3, t7);           // Checks Weil pairing non trivial \r\n\r\n    fp2add751(PKB[1], PKB[2], t0);                     // t0 = xP+xQ\r\n    fp2mul751_mont(PKB[3], t0, t1);                    // t1 = xQP*t0\r\n    fp2sub751(t1, one, t1);                            // t1 = t1-1\r\n    fp2mul751_mont(PKB[1], PKB[2], t2);                // t2 = xP*xQ\r\n    fp2add751(t1, t2, t1);                             // t1 = t2+t1\r\n    fp2sqr751_mont(t1, t1);                            // t1 = t1^2\r\n    fp2add751(t0, PKB[3], t0);                         // t0 = t0+xQP\r\n    fp2add751(PKB[0], t0, t0);                         // t0 = t0+A\r\n    fp2mul751_mont(PKB[3], t2, t2);                    // t2 = t2*xQP\r\n    fp2mul751_mont(t0, t2, t0);                        // t0 = t0*t2\r\n    fp2add751(t0, t0, t0);                             // t0 = t0+t0\r\n    fp2add751(t0, t0, t0);                             // t0 = t0+t0\r\n\r\n    *valid = *valid & is_equal_fp2(t0, t1); \r\n    *valid = *valid & test_curve(PKB[0], rvalue, CurveIsogeny); \r\n\r\n    return CRYPTO_SUCCESS;\r\n}","#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include \"SIDH_internal.h\"\n#include \"SIDH.h\"\n#include \"randombytes.h\"\n#include \"utils.h\"\n\n\nPCurveIsogenyStruct isogeny;\n\nlong public_key_bytes\t\t= 768;\nlong full_public_key_bytes\t= 1536;\nlong private_key_bytes\t\t= 48;\nlong full_private_key_bytes\t= 96;\n\n\nCRYPTO_STATUS sidhjs_randombytes (unsigned int nbytes, unsigned char* random_array) {\n\trandombytes_buf(random_array, nbytes);\n\treturn CRYPTO_SUCCESS;\n}\n\nCRYPTO_STATUS sidhjs_init () {\n\trandombytes_stir();\n\n\tisogeny\t= SIDH_curve_allocate(&CurveIsogeny_SIDHp751);\n\n\treturn SIDH_curve_initialize(\n\t\tisogeny,\n\t\tsidhjs_randombytes,\n\t\t&CurveIsogeny_SIDHp751\n\t);\n}\n\nlong sidhjs_public_key_bytes_base () {\n\treturn public_key_bytes;\n}\n\nlong sidhjs_public_key_bytes () {\n\treturn full_public_key_bytes;\n}\n\nlong sidhjs_private_key_bytes_base () {\n\treturn private_key_bytes;\n}\n\nlong sidhjs_private_key_bytes () {\n\treturn full_public_key_bytes + full_private_key_bytes;\n}\n\nlong sidhjs_secret_bytes () {\n\treturn 192;\n}\n\n\nCRYPTO_STATUS sidhjs_keypair_base (\n\tuint8_t* public_key,\n\tuint8_t* private_key,\n\tint is_alice\n) {\n\tif (is_alice) {\n\t\treturn KeyGeneration_A(private_key, public_key, isogeny);\n\t}\n\telse {\n\t\treturn KeyGeneration_B(private_key, public_key, isogeny);\n\t}\n}\n\nCRYPTO_STATUS sidhjs_keypair (\n\tuint8_t* public_key,\n\tuint8_t* private_key\n) {\n\tCRYPTO_STATUS status\t= sidhjs_keypair_base(public_key, private_key, 1);\n\n\tif (status != CRYPTO_SUCCESS) {\n\t\treturn status;\n\t}\n\n\tstatus\t= sidhjs_keypair_base(\n\t\tpublic_key + public_key_bytes,\n\t\tprivate_key + private_key_bytes,\n\t\t0\n\t);\n\n\tif (status != CRYPTO_SUCCESS) {\n\t\treturn status;\n\t}\n\n\tmemcpy(\n\t\tprivate_key + full_private_key_bytes,\n\t\tpublic_key,\n\t\tfull_public_key_bytes\n\t);\n\n\treturn CRYPTO_SUCCESS;\n}\n\n\nCRYPTO_STATUS sidhjs_secret_base (\n\tuint8_t* public_key,\n\tuint8_t* private_key,\n\tuint8_t* secret,\n\tint is_alice,\n\tint should_validate\n) {\n\tCRYPTO_STATUS (*validate)(unsigned char* pk, bool* v, PCurveIsogenyStruct iso);\n\tCRYPTO_STATUS (*secret_agreement)(unsigned char* sk, unsigned char* pk, unsigned char* s, PCurveIsogenyStruct iso);\n\n\tif (is_alice) {\n\t\tvalidate\t\t\t= Validate_PKB;\n\t\tsecret_agreement\t= SecretAgreement_A;\n\t}\n\telse {\n\t\tvalidate\t\t\t= Validate_PKA;\n\t\tsecret_agreement\t= SecretAgreement_B;\n\t}\n\n\tif (should_validate) {\n\t\tbool valid;\n\t\tCRYPTO_STATUS validate_status\t= validate(public_key, &valid, isogeny);\n\n\t\tif (validate_status != CRYPTO_SUCCESS) {\n\t\t\treturn validate_status;\n\t\t}\n\t\tif (!valid) {\n\t\t\treturn CRYPTO_ERROR_PUBLIC_KEY_VALIDATION;\n\t\t}\n\t}\n\n\treturn secret_agreement(private_key, public_key, secret, isogeny);\n}\n\nCRYPTO_STATUS sidhjs_secret (\n\tuint8_t* public_key,\n\tuint8_t* private_key,\n\tuint8_t* secret\n) {\n\tint is_alice\t= sodium_compare(\n\t\tpublic_key,\n\t\tprivate_key + full_private_key_bytes,\n\t\tfull_public_key_bytes\n\t);\n\n\tif (is_alice == 1) {\n\t\tpublic_key += public_key_bytes;\n\t}\n\telse if (is_alice == -1) {\n\t\tis_alice = 0;\n\t\tprivate_key += private_key_bytes;\n\t}\n\telse {\n\t\treturn CRYPTO_ERROR_INVALID_PARAMETER;\n\t}\n\n\treturn sidhjs_secret_base(\n\t\tpublic_key,\n\t\tprivate_key,\n\t\tsecret,\n\t\tis_alice,\n\t\t1\n\t);\n}\n"]}